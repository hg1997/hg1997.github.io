<!DOCTYPE html>
<html>
<head>
<title>juc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>juc - &gt; java.util.concurrent</h1>
<ul>
<li><a href="#1">java内存模型</a></li>
<li><a href="#2">并发编程三大概念</a></li>
<li><a href="#3">valotile</a></li>
<li><a href="#4">ConcurrentHashMap</a></li>
<li><a href="#5">CountDownLatch</a></li>
<li><a href="#6">Callable</a></li>
<li><a href="#7">线程&amp;生产者消费者&amp;Lock</a></li>
<li><a href="#8">交替打印ABC</a></li>
<li><a href="#9">ReadWriteLock</a></li>
<li><a href="#10">线程池</a></li>
<li><a href="#11">线程池调度</a></li>
</ul>
<h2><span id='1'>java内存模型<span></h2>
<p>&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。</p>
<ul>
<li>线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。</li>
<li>不同线程之间也无法直接访问对方工作内存中的变量</li>
<li>线程间变量值的传递均需要通过主内存来完成。</li>
</ul>
<p><img src="https://i.imgur.com/6JCkrki.png" /></p>
<p>eg：</p>
<pre><code>int a = 0;

a++;  //100个线程并发操作

sout(a); 
//输入a的结果不一定为100，可能线程1读取a的值后，线程2获得cpu执行权也去读取a的值；

//假如这时两个线程读取到各自线程中工作内存中a的值都是10，之后两者都执行++操作，得到a最终结果为11
</code></pre>

<h2><span id='2'>并发编程三大概念<span></h2>
<ol>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ol>
<p><strong><font color='red'>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</font></strong></p>
<blockquote>
<p>可见性</p>
</blockquote>
<pre><code> //线程1执行的代码
 int i = 0;
 i = 10;

 //线程2执行的代码
 j = i;

由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
</code></pre>

<hr />
<ul>
<li>对于可见性，Java提供了volatile关键字来保证可见性。</li>
<li>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li>
<li>而普通的共享变量不能保证可见性，<font color='red'>因为普通共享变量被修改之后，什么时候被写入主存是不确定的，</font>当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li>
<li>
<font color='red'>如果一个线程只负责对变量进行读取，在第一次从主存中读取后不是后面的任何时刻该线程对该变量的读取都是从自己的工作内存中读取
<ul>
<li>如果来得及会从主存中再读取，相当于修改自己线程中的缓存数据</li>
<li>如果来不及就一直使用缓存中的数据（<em>出现内存可见性问题</em>）
</font></li>
</ul>
</li>
</ul>
<p>【保证措施】</p>
<p><strong>1. 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，<font color='red'>并且在释放锁之前会将对变量的修改刷新到主存当中。</font>因此可以保证可见性。</strong></p>
<p><strong>2. volatile关键字</strong></p>
<blockquote>
<p>原子性</p>
</blockquote>
<pre><code>如：转账例子

x = 10;         //语句1【为原子操作】
----------------------------------
y = x;         //语句2
   1.从主存读取到x的值  
   2.将读取到的值写入到线程自己的工作内存（线程自己的缓存区域）
---------------------------------
x++;           //语句3
   1. 读x的值
   2. 改x的值（+1）
   3. 写入新值
---------------------------------
x = x + 1;     //语句4
   1. 读x的值
   2. 改x的值（+1）
   3. 写入新值
</code></pre>

<ul>
<li>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类如<font color='red'>AtomicInteger</font></li>
<li>
<p>对基本数据类型的 自增（加1操作）,自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<p><font color='red'>通过两种策略实现</font></p>
<ol>
<li>在AtomicInteger源码中对成员添加volatile关键字，保证内存可见性</li>
<li>
<p><font color='red'>利用CAS（Compare And Swap）算法，保证原子性</font></p>
<ul>
<li>CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</li>
<li>硬件对于并发操作共享数据的支持</li>
<li>无锁的非阻塞算法</li>
<li>
<p>三个操作数：</p>
<p>1.第一次从主存中读取的值v（相当于线程的缓存值） </p>
<p>2.再次从主存中读取的值A </p>
<p>3.更新值B(结果值)</p>
<ul>
<li>当且仅当 v == A , 则B 赋值给 V，实现修改</li>
<li>否则，不进行操作</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>【保证措施】</p>
<p>&emsp;&emsp;<strong>synchronized和Lock可以保证原子性</strong></p>
<blockquote>
<p>有序性</p>
</blockquote>
<p>指令重排序：</p>
<pre><code> 1.一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化
 2.它不保证程序中各个语句的执行先后顺序同代码中的顺序一致
 3.但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
</code></pre>

<hr />
<pre><code>int i = 0;              
boolean flag = false;

i = 1;                //语句1  
flag = true;          //语句2

语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。
</code></pre>

<hr />
<pre><code>int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4

可能是2-1-3-4
但不肯是2-1-4-3，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
</code></pre>

<hr />
<pre><code>//线程1:

context = loadContext();   //语句1
inited = true;             //语句2

 //线程2:
while(!inited ){
   sleep()
}
doSomethingwithconfig(context);

由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。
</code></pre>

<hr />
<p><strong><font color='red'>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</font></strong></p>
<p>【保证措施】</p>
<p><strong>volatile可以保证有序性【内存栅栏】</strong></p>
<p><strong>Synchronized 和 Lock 可以保证有序性</strong></p>
<h2><span id='3'>volatile<span></h2>
<ul>
<li>保证可见性</li>
<li><font color='red'>不保证原子性</font></li>
<li>保证顺序性</li>
</ul>
<blockquote>
<p>保证可见性</p>
</blockquote>
<pre><code>//线程1
volatile boolean stop = false;
while(!stop){
doSomething();
}

//线程2
stop = true;    

使用volatile后：
1.强制让修改后的值从线程缓存中写入主存
2.线程2修改后的值强制写到了主存，同时让线程1的缓存数据失效
3.线程1的缓存数据失效后会再读取出存中的数据，保证了及时感知到其他线程对变量的改变操作
</code></pre>

<p><strong>【原理】</strong></p>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>
<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 <strong>这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</strong></p>
<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。<strong>这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的</strong></p>
<blockquote>
<p>不保证原子性</p>
</blockquote>
<pre><code>public class Test {
public volatile int inc = 0;

public void increase() {
    inc++;
}

public static void main(String[] args) {
    final Test test = new Test();
    for(int i=0;i&lt;10;i++){
        new Thread(){
            public void run() {
                for(int j=0;j&lt;1000;j++)
                    test.increase();
            };
        }.start();
    }

    while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完
        Thread.yield();
    System.out.println(test.inc);
}
}
</code></pre>

<p>&gt; <strong>10个线程，每个线程累计自增1000 == 》结果比10*1000=10000这个数小</strong></p>
<blockquote>
<p>保证顺序性</p>
</blockquote>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>可能上面说的比较绕，举个简单的例子：</p>
<pre><code>//x、y为非volatile变量
//flag为volatile变量

x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
</code></pre>

<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<pre><code>//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
</code></pre>

<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>【原理】</strong></p>
<p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<h2><span id='4'>ConcurrentHashMap<span></h2>
<p><img src="https://i.imgur.com/INMdlxU.png" /></p>
<hr />
<ul>
<li>采用&quot;锁分段机制&quot;（HashTable是独占锁）</li>
<li>
默认的并发级别concurrencyLevel=16
<ul>
<li>即16个sengment,分为16段，每个段都是独立的锁</li>
<li>每一段是一个Hash表，同样初始容量大小是16</li>
</ul>
</li>
<li>jdk8使用了CAS,无锁算法，无阻塞</li>
<li>是fast-safe的，基于克隆，不存在并发修改异常ConcurrentModificationException</li>
</ul>
<blockquote>
<p>CopyOnWriteArrayList/Set:</p>
</blockquote>
<ul>
<li>每次写入都会复制，基于克隆，不存在并发修改异常</li>
<li>
每次都复制导致效率低下
<ul>
<li>添加次数多，不适合使用</li>
<li>并发迭代次数多，使用</li>
</ul>
</li>
</ul>
<h2><span id='5'>CountDownLatch<span></h2>
<ul>
<li>闭锁，在完成某些运算时，只有其他所有线程的运算全部完成，当前运算才继续执行</li>
<li>可以通过t1.join()达到此效果</li>
</ul>
<hr />
<pre><code> import java.util.concurrent.CountDownLatch;
 public class TestCountDownLatch {
    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(50);  //创建闭锁构造函数的个数与线程数相同
        LatchDemo ld = new LatchDemo(latch);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 50; i++) {  //50个线程，与闭锁创建时的构造参数传递的个数对应
            new Thread(ld).start();
        }

        try {
            latch.await();  //在闭锁没减到0之前，等待，减到0之后会释放当前等待的线程
         } catch (InterruptedException e) {
        }

        long end = System.currentTimeMillis();

        System.out.println(&quot;耗费时间为：&quot; + (end - start));
      }

     }
</code></pre>

<hr />
<pre><code> class LatchDemo implements Runnable {

     private CountDownLatch latch;

     public LatchDemo(CountDownLatch latch) {
        this.latch = latch;
     }

    @Override
    public void run() {

        try {
            for (int i = 0; i &lt; 50000; i++) {
                if (i % 2 == 0) {
                    System.out.println(i);
                }
            }
        } finally { //放在finally中，保证一定得减1
            latch.countDown();   //线程执行完，减1
        }
    }
}
</code></pre>

<h2><span id='6'>Callable<span></h2>
<ul>
<li>jdk1.5在java.util.concurrent提供了Callable接口</li>
<li>类似实现Runnable接口，但是Callable方式可以有返回值，而且会抛异常</li>
<li>
需要依赖FutureTask
<ul>
<li>是Future接口的实现类，接收运算结果</li>
<li>间接实现了Runnable接口，所以创建FutureTask对象可作为new Thread（）的构造参数</li>
<li>FutureTask也可作为闭锁【因为接收的是线程执行完毕后的结果】</li>
</ul>
</li>
</ul>
<hr />
<pre><code>public class TestCallable {

    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();

        //1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。
        FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td);  //传递实现了Callable接口的实现类

        new Thread(result).start();   //将FutureTask作为参数传递给Thread的构造函数

        //2.接收线程运算后的结果
        try {
            Integer sum = result.get();  //FutureTask接收结果 可用于 闭锁
            System.out.println(sum);
            System.out.println(&quot;------------------------------------&quot;);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<hr />
<pre><code>class ThreadDemo implements Callable&lt;Integer&gt;{  //实现Callable接口

    @Override
    public Integer call() throws Exception {   //重写call方法
        int sum = 0;

        for (int i = 0; i &lt;= 100000; i++) {
            sum += i;
        }   
        return sum;
    }
}
</code></pre>

<h2><span id='7'>多线程&amp;生产者消费者&amp;Lock<span></h2>
<blockquote>
<p>单生产问题</p>
</blockquote>
<pre><code>1. 生产方法和消费方法未同步，导致消费之前生产的产品
    * 解决：添加synchronize
2. 出现连续生产连续消费
    * 标记变量flag，结合wait/notify
</code></pre>

<blockquote>
<p>多生产问题</p>
</blockquote>
<pre><code>1. 出现极端的问题：只一直生产不消费 or 只一直消费不生产
    * 因为程序会从wait（）被唤醒的地方向下执行而不会再去判断标记变量，出现生产者（消费者）之间彼此交替唤醒
    * 解决if--&gt;改为while ：  解决虚假唤醒的问题   Object#wait--API描述
2. 死锁：
    * notify改为notifyAll
3. 上述解决死锁的方法效率低，一次唤醒全部
    * 使用jdk1.5出现的Lock接口-- Condition的await和signal方法
        * 用两套condition对生产者和消费者这两个对立的线程进行针对性唤醒
        * 生产者生产后针对性唤醒消费者
        * 消费者消费后正对性唤醒生产者
        * 【避免了使用传统的notify唤醒本方出现死锁导致使用notifyAll解决死锁但又导致效率低的问题】

   *  查看Condition的API,有两套condition,使用两套监视器方法唤醒对方的示例代码
</code></pre>

<h2><span id='8'>交替重复打印ABC<span></h2>
<pre><code>public class Main {  //【执行类】
    public static void main(String[] args) {
        Resource resource  =  new Resource();

        new Thread(new SoutA(resource)).start();
        new Thread(new SoutB(resource)).start();
        new Thread(new SoutC(resource)).start();
    }
}
</code></pre>

<hr />
<pre><code>class Resource{ //【打印功能封装的类】
    int x = 1;

    Lock lock = new ReentrantLock();

    //3个线程，3套condition
    Condition a = lock.newCondition();
    Condition c = lock.newCondition();
    Condition b = lock.newCondition();

    //负责打印A,修改标记唤醒B
    public void soutA(){
        lock.lock();

        try{
            if(x != 1){
                try {
                    a.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.print(&quot;A&quot;);
            x = 2;
            b.signal();

        }finally {
            lock.unlock();
        }
    }

    //负责打印B，修改标记唤醒C
    public void soutB(){
        lock.lock();

       try{
           if(x != 2){
               try {
                   b.await();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }

           System.out.print(&quot;B&quot;);
           x = 3;
           c.signal();
       }finally {
            lock.unlock();
       }
    }

    //负责打印C，修改标记唤醒A
    public void soutC(){
        lock.lock();

       try{
           if(x != 3){
               try {
                   c.await();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
           System.out.print(&quot;C&quot;);
           x = 1;
           a.signal();
       }finally {
           lock.unlock();
       }
    }
}
</code></pre>

<hr />
<pre><code>class SoutA implements Runnable{  //打印A的线程，for控制打印次数

    Resource resource;

    public SoutA(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        for(int x=1;x&lt;=10;x++){
            resource.soutA();
        }
    }
}

class SoutB implements Runnable{ //打印B的线程，for控制打印次数

    Resource resource;

    public SoutB(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        for(int x=1;x&lt;=10;x++){
            resource.soutB();
        }
    }
}

class SoutC implements Runnable{ //打印C的线程，for控制打印次数

    Resource resource;

    public SoutC(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        for(int x=1;x&lt;=10;x++){
            resource.soutC();
        }
    }
}
</code></pre>

<h2><span id='9'>ReadWriteLock<span></h2>
<p><img src="https://i.imgur.com/YLv1giv.png" /></p>
<hr />
<ul>
<li>写写 / 读写  -- &gt; 互斥的</li>
<li>读读        -- &gt;  不用互斥</li>
</ul>
<hr />
<p>ReadWriteLock 维护了一对相关的锁</p>
<p><font color='red'>创建该【接口】实现类【ReentrantReadWriteLock】的对象</font></p>
<p><font color='red'>ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</font></p>
<ul>
<li>
一个锁用于只读操作，另一个用于写入操作。
<ul>
<li>readWriteLock.readLock().lock() / unLock()</li>
<li>readWriteLock.writeLock().lock() / unLock()</li>
</ul>
</li>
<li>只要没有 writer，读取锁可以由多个 reader 线程同时保持</li>
<li>写入锁是独占的。 </li>
</ul>
<hr />
<pre><code>public class Main {
    public static void main(String[] args) {
        final ReadWriteDemo readWriteDemo = new ReadWriteDemo();

        //一个线程写 
        new Thread(()-&gt;readWriteDemo.write(&quot;hg&quot;), &quot;write&quot;).start();

        //100个线程读
        for(int x=1;x&lt;=100;x++){
            new Thread(()-&gt;readWriteDemo.read(),&quot;read&quot;).start();
        }
    }
}
</code></pre>

<hr />
<pre><code>class ReadWriteDemo{

    String name;

    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    public void read(){  //上【读锁】和释放【读锁】
        readWriteLock.readLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+&quot;**********&quot;+name);
        }finally {
            readWriteLock.readLock().unlock();
        }
    }

    public void write(String name){//上【写锁】和释放【写锁】
        readWriteLock.writeLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+&quot;---写入--&quot;+name);
            this.name = name;
        }finally {
            readWriteLock.writeLock().unlock();
        }
    }
}
</code></pre>

<h2><span id='10'>线程池<span></h2>
<ul>
<li>1.5之后提供。java.util.concurrent</li>
<li>同数据库连接池，负责维护线程的创建和管理，回收</li>
<li>提供一个线程队列，队列中保存着所有等待状态的线程</li>
</ul>
<blockquote>
<p>线程体系结构</p>
</blockquote>
<pre><code>    java.util.concurrent.Executor : 负责线程的使用与调度的根接口
    |--ExecutorService 子接口: 线程池的主要接口
        |--ThreadPoolExecutor 线程池的实现类
        |--ScheduledExecutorService 子接口：负责线程的调度
            |--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService【兼备线程池和线程调度】
</code></pre>

<blockquote>
<p>工具类 : Executors </p>
</blockquote>
<pre><code>  ExecutorService newFixedThreadPool() : 创建固定大小的线程池
  ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。
  ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程
</code></pre>

<blockquote>
<p>代码演示</p>
</blockquote>
<pre><code>//1. 创建线程池【固定大小线程池5个】
ExecutorService pool = Executors.newFixedThreadPool(5);

//2.调用线程池方法【会从线程池中分配[任意一个线程]执行传递的线程任务】
pool.submit（xxx）  //接收Runnable和Callable参数，子类实现作为线程任务对象

//3.关闭
pool.shutdown();  //平缓关闭
pool.shutdownNow();  //立即强制关闭
</code></pre>

<h2><span id='11'>线程调度<span></h2>
<p>可安排在给定的延迟后运行或定
期执行的命令。</p>
<blockquote>
<p>工具类 : Executors </p>
</blockquote>
<p>Executors.newScheduledThreadPool()  返回ScheduledExecutorService  </p>
<p>创建固定大小的线程，可以延迟或定时的执行任务。</p>
<pre><code>public static void main(String[] args) throws Exception {
    //工具类获取实例,线程池初始化5个线程
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(5);

    //对应线程池初始化的5个线程，各自都分配线程任务
    for (int i = 0; i &lt; 5; i++) {
        //schedule方法三个参数：第一个是线程任务，第二个是延时时间，第三个是时间的单位
        Future&lt;Integer&gt; result = pool.schedule(new Callable&lt;Integer&gt;(){

            @Override
            public Integer call() throws Exception {
                int num = new Random().nextInt(100);//生成随机数
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + num);
                return num;
            }

        }, 1, TimeUnit.SECONDS);  //每个一秒钟执行一次

        System.out.println(result.get());
    }   
    pool.shutdown();
}   
</code></pre>

<h2><span id='12'>fork/join框架<span></h2>
<p><font color='red'>jdk1.7之后出现的</font></p>
<p><font color='red'>jdk1.8之后出现新方式，进行了改进</font>
<img src="https://i.imgur.com/Dn0jrpg.png" />
<img src="https://i.imgur.com/of89zKv.png" /></p>
<hr />
<blockquote>
<p>实现方式</p>
</blockquote>
<ul>
<li>继承RecursiveTask -- 有返回值</li>
<li>继承RecursiveAction -- 无返回值</li>
</ul>
<hr />
<pre><code>public class TestForkJoinPool { 
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();  

        //进行的任务--【计算0-50000000000L】的和
        ForkJoinTask&lt;Long&gt; task = new ForkJoinSumCalculate(0L, 50000000000L);

        Long sum = pool.invoke(task);

        System.out.println(sum);
    }

class ForkJoinSumCalculate extends RecursiveTask&lt;Long&gt;{ //继承RecursiveTask

    private static final long serialVersionUID = -259195479995561737L;

    private long start;
    private long end;

    private static final long THURSHOLD = 10000L;  //临界值

    public ForkJoinSumCalculate(long start, long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() { //重写继承的方法
        long length = end - start;

        if(length &lt;= THURSHOLD){ //小于临界值,直接进行计算
            long sum = 0L;
            for (long i = start; i &lt;= end; i++) {
                sum += i;
            }
            return sum;
        }else{   //大于临界值，进行拆分
            long middle = (start + end) / 2;

            ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle); 
            left.fork(); //进行拆分，同时压入线程队列【分成左边部分】

            ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle+1, end);
            right.fork(); //进行拆分，同时压入线程队列【分成右边部分】

            return left.join() + right.join();   //【合并】
        }
    }

}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
