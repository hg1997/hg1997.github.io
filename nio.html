<!DOCTYPE html>
<html>
<head>
<title>nio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>nio</h1>
<ul>
<li><a href="#1">概述</a></li>
<li>
<a href="#2">缓冲区</a>
<ul>
<li><a href="#2.1">缓冲区基本属性</a></li>
<li><a href="#2.2">缓冲区常用方法</a></li>
</ul>
</li>
<li><a href="#3">直接缓冲区</a></li>
<li><a href="#4">通道</a></li>
<li><a href="#5">Charset</a></li>
<li><a href="#6">nio的非阻塞</a></li>
<li><a href="#7">管道</a></li>
<li><a href="#8">nio2</a></li>
</ul>
<h2><span id='1'>概述</span></h2>
<ul>
<li>
<p>nio从1.4就有，1.7进行了改进（nio2）</p>
<ul>
<li>传统io:面向流，阻塞的</li>
<li>
<p>nio:面向缓冲区，基于通道；非阻塞；有选择器（selector）</p>
<ul>
<li>
<p>通道：表示打开到io设备，套接字的连接【相当于铁轨】</p>
</li>
<li>
<p>缓冲区：装数据【相当于火车，是双向的，通过方法flip切换读写】</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id='2'>缓冲区</span></h2>
<ul>
<li>用于基本数据类型的容器，由java.nio包定义</li>
<li>数据结构是数组</li>
<li>
8个基本数据类型除了boolean，其余7个差不多【ByteBuffer】
<ul>
<li><font color='red'>都是Buffer抽象类的子类</font></li>
</ul>
</li>
<li>【读】：从通道读入缓冲区  </li>
<li>【写】：从缓冲区写入通道	</li>
<li>写数据&emsp;&emsp; <font color='red'>put()方法</font></li>
<li>
<p>读数据&emsp;&emsp; <font color='red'>get()方法</font></p>
</li>
<li>
<p><font color='red'>实例化</p>
<ul>
<li>static XXXBuffer allocate(int capacity);</li>
<li>ByteBuffer byteBuffer = ByteBuffer.allocate(1024);	
   </font></li>
</ul>
</li>
</ul>
<hr />
<h2><span id='2.1'>缓冲区基本属性</span></h2>
<pre><code>在Buffer这个抽象父类中定义了4个重要的变量：
  * 1.capacity:缓冲区的容量，一旦声明不可变【因为是数组】

  * 2.limit:表示操作数据的界限，limit后面的数据不能再操作（读写）

  * 3.position:表示缓冲区中将要操作数据的【下一个位置】

  * 4.mark:
      * 通过【Buffer的mark()方法】记录position的位置
      * 在position操作了数据位置发生变化后，通过【Buffer的reset()方法】可以恢复到mark标识的position的原始位置

  0 &lt;= limit &lt;= position &lt;= limit &lt;= capacity
</code></pre>

<p><img src="https://i.imgur.com/Vwbg01n.png" /></p>
<hr />
<h2><span id='2.2'>缓冲区常用方法</span></h2>
<p><img src="https://i.imgur.com/SmBbqol.png" /></p>
<ul>
<li>clear:将position,limit,capacity的位置还原为初始位置，但是数据并未清空，处于&quot;被遗忘&quot;状态</li>
<li>flip:切换到读数据模式，将position置0，limit置为刚才position的位置0</li>
<li>rewind:效果同flip，可重复读</li>
<li>
<p>mark:设置mark的值，reset:将position的值还原到mark位置的值</p>
<p><img src="https://i.imgur.com/YrU5KLY.png" /></p>
</li>
</ul>
<hr />
<h2><span id='3'>直接缓冲区</span></h2>
<ul>
<li>
非直接缓冲区
<ul>
<li>通过allocate()方法分配。建立在jvm内存中</li>
<li><font color='red'>通过二次copy</font></li>
</ul>
</li>
<li>
直接缓冲区
<ul>
<li>建立在系统的物理内存中</li>
<li><font color='red'>创建和销毁的开销高于创建普通的非直接缓冲区</font></li>
<li><font color='blue'>只有ByteBuffer支持直接缓冲区，其他的xxBuffer不支持</font></li>
<li>
<font color='red'>直接建立映射，不需要中间的copy操作，提高效率。</font>
<ul>
<li>
<font color='blue'>创建直接缓冲区两种方式</font>
<ul>
<li>通过allocateDiret()方法分配</li>
<li>通过FileChannel的map()方法将文件区域直接映射到内存中创建，返回MappedByteBuffer;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>通过isDirect()方法可以查看是否为直接缓冲区</strong></p>
<h2><span id='4'>通道</span></h2>
<p><img src="https://i.imgur.com/68mGm4E.png" /></p>
<ul>
<li>表示与io接口，socket的连接</li>
<li>
与传统的“流”相似
<ul>
<li>但是，【通道本身不能自己去访问数据（流可以）】，【只能传递数据】</li>
<li>依赖Buffer缓冲区来存储数据，通过Bufferla来完成数据的传输</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>通道提高效率</p>
</blockquote>
<pre><code>操作系统底层的io接口由cpu来管控
* 传统的IO由DMA(直接存储器)与内存打交道，响应IO接口的调用请求需要申请cpu的批准
* nio将DMA换做Channel(通道)与内存打交道，他是一个完全独立的处理器（附属于cpu）,专门负责io操作，不需要申请
</code></pre>

<blockquote>
<p>通道的继承体系</p>
</blockquote>
<pre><code>java.nio.channels.Channel 接口：
    |--FileChannel  //操作本地文件
    |--SocketChannel   //TCP
    |--ServerSocketChannel
    |--DatagramChannel   //UDP
</code></pre>

<blockquote>
<p>获取通道三种方式</p>
</blockquote>
<pre><code>1. Java 针对支持通道的类提供了 getChannel() 方法
    本地 IO：
    FileInputStream/FileOutputStream
    RandomAccessFile

    网络IO：
    Socket
    ServerSocket
    DatagramSocket

2. 在 【JDK 1.7】 中的 NIO.2 针对各个通道提供了静态方法 open()
    * 类名.open()  -- &gt; 获取实例对象
3. 在 【JDK 1.7】 中的 NIO.2 的 Files 工具类的 newByteChannel()
    * Files.newByteChannel();
</code></pre>

<blockquote>
<p>上代码</p>
<p><strong>使用第一种获取Channel方法</strong></p>
</blockquote>
<p><strong>使用【非直接缓冲区】</strong></p>
<pre><code>拷贝文件：
         fileInputStream = new FileInputStream(&quot;c:/D盘/a.jpg&quot;);
         fileOutputStream = new FileOutputStream(&quot;c:/D盘/aa.jpg&quot;);

         channelIn = fileInputStream.getChannel();
         channelOut = fileOutputStream.getChannel();

        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        while(channelIn.read(byteBuffer)!=-1){
            byteBuffer.flip();   //将缓冲区切换为【读模式】，从而目标通道可以读取缓冲区数据将读到的数据写入目标通道对应的文件目的地
            channelOut.write(byteBuffer);
            byteBuffer.clear();  //注意要将缓冲区清空用于下次重复写入数据
        }

        System.out.println(&quot;完毕。。。。。&quot;);

        //xxx  后续记得关闭close流和通道
</code></pre>

<blockquote>
<p><strong>使用第二种获取Channel方法</strong></p>
</blockquote>
<ul>
<li>
public static FileChannel open(Path path,OpenOption... options)
<ul>
<li>FileChannel.open(Paths.get(&quot;xx.jpg&quot;),StandardOpenOption.READ)</li>
</ul>
</li>
</ul>
<p><strong>使用【直接缓冲区】</strong></p>
<pre><code>    //读通道
    FileChannel inChannel = FileChannel.open(Paths.get(&quot;d:/1.mkv&quot;), StandardOpenOption.READ); 
    //写通道
    FileChannel outChannel = FileChannel.open(Paths.get(&quot;d:/2.mkv&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);

    //内存映射文件【第二种获取直接缓冲区的方法，通过通道进行映射】
    MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size());//[读通道关联的文件]有多大（size()）就对应多大的直接缓冲区【用于存储读的数据】
    MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size());//[读通道关联的文件]有多大（size()），就对应多大的直接缓冲区【用于存储写入的数据】

    //直接对缓冲区进行数据的读写操作
    byte[] dst = new byte[inMappedBuf.limit()];
    inMappedBuf.get(dst);//此时inMappedBuf缓存区里面已经有数据了，postion=0,limit=capacity=size,所以此处不需要再flip()切换为读模式
    outMappedBuf.put(dst);//outMappedBuf是空的，往里面写就ok

    inChannel.close();
    outChannel.close();
</code></pre>

<blockquote>
<p><strong>通道之间的数据传输</strong></p>
</blockquote>
<pre><code>//通道之间的数据传输
    * 直接缓冲区
    * 可能存在文件拷贝完，程序还未停止的情况【jvm还没释放内存】
@Test
public void test3() throws IOException{

    FileChannel inChannel = FileChannel.open(Paths.get(&quot;d:/1.mkv&quot;), StandardOpenOption.READ);
    FileChannel outChannel = FileChannel.open(Paths.get(&quot;d:/2.mkv&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);

    【两种方式任选其一】：核心就是从哪来，到哪去
   //inChannel.transferTo(0, inChannel.size(), outChannel);
    outChannel.transferFrom(inChannel, 0, inChannel.size());

    inChannel.close();
    outChannel.close();
}
</code></pre>

<blockquote>
<p><strong>分散(Scatter)与聚集(Gather)</strong></p>
</blockquote>
<ul>
<li>分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中</li>
<li>聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中</li>
<li>
<p><font color='red'>其实就是传递一个ByteBuffer[]数组进行整体的读写</font></p>
<pre><code>    public void test4() throws IOException{
    RandomAccessFile raf1 = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);

    //1. 获取通道
    FileChannel channel1 = raf1.getChannel();

    //2. 分配指定大小的缓冲区
    ByteBuffer buf1 = ByteBuffer.allocate(100);
    ByteBuffer buf2 = ByteBuffer.allocate(1024);

    //3. 分散读取，【传递一个buffer数组】
    ByteBuffer[] bufs = {buf1, buf2};
    channel1.read(bufs);

    for (ByteBuffer byteBuffer : bufs) {
        byteBuffer.flip();
    }

    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));
    System.out.println(&quot;-----------------&quot;);
    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));

    //4. 聚集写入
    RandomAccessFile raf2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;);
    FileChannel channel2 = raf2.getChannel();

    channel2.write(bufs);【将buffer数组作为整体读取】
}
</code></pre>

</li>
</ul>
<h2><span id='5'>Charset</span></h2>
<pre><code> @Test
public void test() throws Exception {
    //设置编码
    Charset charset = Charset.forName(&quot;gbk&quot;);

    //编码和解码器
    CharsetEncoder encoder = charset.newEncoder();
    CharsetDecoder decoder = charset.newDecoder();

    //分配缓冲区
    CharBuffer in = CharBuffer.allocate(1024);
    in.put(&quot;这是一个测试&quot;);
    in.flip();//【注意flip切换为读模式，从而将读取的字符串转换为字节】

    //编码【字符转换为字节】
    ByteBuffer byteBuffer = encoder.encode(in);

    //解码【字节转换为字符】
    CharBuffer out = decoder.decode(byteBuffer);

    //正常完成解码
    System.out.println(out.toString());
}
</code></pre>

<h2><span id='6'>nio的非阻塞</span></h2>
<ul>
<li>
<p>传统io	</p>
<ul>
<li>传统io的read和write方法是阻塞的</li>
<li>在进行网络通信时服务器为每个客户端分配一个线程，过多时效率低</li>
<li><font color='red'>服务器一个线程处理【一个】客户端</font></li>
</ul>
</li>
<li>
<p>nio</p>
<ul>
<li>选择器（selector）监听多个管道（事件监听）</li>
<li>服务器可以用一个线程对应处理多个连接的客户端</li>
<li><font color='red'>服务器一个线程处理【多个】个客户端</font></li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>SelectableChannel</p>
</blockquote>
<ul>
<li>FileChannel不可用于非阻塞，所以只剩下以下网络Channel可用于非阻塞</li>
</ul>
<hr />
<pre><code>java.nio.channels.Channel 接口：
 *          |--SelectableChannel 
 *              【网络的Channel都是SelectableChannel】
 *              |--SocketChannel
 *              |--ServerSocketChannel
 *              |--DatagramChannel

                【管道(Pipe)相关的Channel】
 *              |--Pipe.SinkChannel
 *              |--Pipe.SourceChannel
</code></pre>

<blockquote>
<p>selector</p>
</blockquote>
<p>Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector
可使一个单独的线程管理多个 Channel。 Selector 是非阻塞 IO 的核心。
<img src="https://i.imgur.com/NNf15jB.png" /></p>
<pre><code>(1)创建Selector
Selector selector = Selector.pen();

(2)将channel转换为非阻塞
channel.configureBlocking(false);

(3)将多个SelectableChannel注册到一个选择器中
SelectionKey key = SelectableChannel.regist(Selector sel,int ops)

    * 第二个参数ops表示监听事件
        &gt; 读：SelectionKey.OP_READ
        &gt; 写：SelectionKey.OP_WRITE
        &gt; 连接：SelectionKey.OP_CONNECT
        &gt; 接收：SelectionKey.OP_ACCEPT

    * 可以同时监听多个事件【管道符进行连接】
    int ops = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>

<blockquote>
<p>SelectionKey</p>
</blockquote>
<pre><code>SelectionKey： 表示 SelectableChannel 和 Selector 之间的注册关系

SelectableChannel:事件源
SelectionKey：事件
Selector:监听器
</code></pre>

<blockquote>
<p>selector的方法</p>
</blockquote>
<p><img src="https://i.imgur.com/JOOB8p7.png" /></p>
<ul>
<li>keys():注册的事件时哪些</li>
<li>selectedKeys():已经触发的事件是哪些</li>
<li>
select()
<ul>
<li>这是一个阻塞式方法！</li>
<li>当有监听的channel有要执行io操作才返回</li>
<li>返回已经绑定的事件已经触发了的Channel数量。</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>代码</p>
</blockquote>
<p><strong>（1）传统的阻塞的演示</strong></p>
<pre><code>//客户端
@Test
public void client() throws IOException{
    //1. 获取通道
    SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));

    FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ);

    //2. 分配指定大小的缓冲区
    ByteBuffer buf = ByteBuffer.allocate(1024);

    //3. 读取本地文件，并发送到服务端
    while(inChannel.read(buf) != -1){
        buf.flip();
        sChannel.write(buf);
        buf.clear();
    }

    //4. 关闭通道
    inChannel.close();
    sChannel.close();
}

====================================

//服务端
@Test
public void server() throws IOException{
    //1. 获取通道
    ServerSocketChannel ssChannel = ServerSocketChannel.open();


    //2. 绑定连接
    ssChannel.bind(new InetSocketAddress(9898));

    //3. 获取客户端连接的通道
    SocketChannel sChannel = ssChannel.accept();

    //4. 分配指定大小的缓冲区
    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.jpg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
    ByteBuffer buf = ByteBuffer.allocate(1024);

    //5. 接收客户端的数据，并保存到本地
    while(sChannel.read(buf) != -1){
        buf.flip();
        outChannel.write(buf);
        buf.clear();
    }

    //6. 关闭通道
    sChannel.close();
    outChannel.close();
    ssChannel.close();      
}
</code></pre>

<p><strong>（2）TCP非阻塞</strong></p>
<pre><code>//客户端
@Test
public void client() throws IOException{
    //1. 获取通道
    SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));

    //2. 切换非阻塞模式
    sChannel.configureBlocking(false);

    //3. 分配指定大小的缓冲区
    ByteBuffer buf = ByteBuffer.allocate(1024);

    //4. 发送数据给服务端
    Scanner scan = new Scanner(System.in);

    while(scan.hasNext()){
        String str = scan.next();
        buf.put((new Date().toString() + &quot;\n&quot; + str).getBytes());
        buf.flip();
        sChannel.write(buf);
        buf.clear();
    }

    //5. 关闭通道
    sChannel.close();
}

    ============================================

//服务端
@Test
public void server() throws IOException{
    //1. 获取通道
    ServerSocketChannel ssChannel = ServerSocketChannel.open();

    //2. 切换非阻塞模式
    ssChannel.configureBlocking(false);

    //3. 绑定连接
    ssChannel.bind(new InetSocketAddress(9898));

    //4. 获取选择器
    Selector selector = Selector.open();

    //5. 将通道注册到选择器上, 并且指定“监听接收事件”
    ssChannel.register(selector, SelectionKey.OP_ACCEPT);

    //6. 轮询式的获取选择器上已经“准备就绪”的事件
    while(selector.select() &gt; 0){

        //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”
        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();

        while(it.hasNext()){
            //8. 获取准备“就绪”的是事件
            SelectionKey sk = it.next();

            //9. 判断具体是什么事件准备就绪
            if(sk.isAcceptable()){
                //10. 若“接收就绪”，获取客户端连接
                SocketChannel sChannel = ssChannel.accept();

                //11. 切换非阻塞模式
                sChannel.configureBlocking(false);

                //12. 将该通道注册到选择器上
                sChannel.register(selector, SelectionKey.OP_READ);
            }else if(sk.isReadable()){
                //13. 获取当前选择器上“读就绪”状态的通道
                SocketChannel sChannel = (SocketChannel) sk.channel();

                //14. 读取数据
                ByteBuffer buf = ByteBuffer.allocate(1024);

                int len = 0;
                while((len = sChannel.read(buf)) &gt; 0 ){
                    buf.flip();
                    System.out.println(new String(buf.array(), 0, len));
                    buf.clear();
                }
            }

            //15. 取消选择键 SelectionKey
            it.remove();
        }
    }
}
</code></pre>

<p><strong>（3）UDP非阻塞</strong></p>
<pre><code>@Test
public void send() throws IOException{
    DatagramChannel dc = DatagramChannel.open();

    dc.configureBlocking(false);

    ByteBuffer buf = ByteBuffer.allocate(1024);

    Scanner scan = new Scanner(System.in);

    while(scan.hasNext()){
        String str = scan.next();
        buf.put((new Date().toString() + &quot;:\n&quot; + str).getBytes());
        buf.flip();
        dc.send(buf, new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));
        buf.clear();
    }

    dc.close();
}

====================================================

@Test
public void receive() throws IOException{
    DatagramChannel dc = DatagramChannel.open();

    dc.configureBlocking(false);

    dc.bind(new InetSocketAddress(9898));

    Selector selector = Selector.open();

    dc.register(selector, SelectionKey.OP_READ);

    while(selector.select() &gt; 0){
        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();

        while(it.hasNext()){
            SelectionKey sk = it.next();

            if(sk.isReadable()){
                ByteBuffer buf = ByteBuffer.allocate(1024);

                dc.receive(buf);
                buf.flip();
                System.out.println(new String(buf.array(), 0, buf.limit()));
                buf.clear();
            }
        }

        it.remove();
    }
}
</code></pre>

<h2><span id='7'>管道（Piped）</span></h2>
<p><img src="https://i.imgur.com/kRmFpxS.png" /></p>
<pre><code>@Test
public void test1() throws IOException{
    //1. 获取管道
    Pipe pipe = Pipe.open();

    //2. 将缓冲区中的数据写入管道
    ByteBuffer buf = ByteBuffer.allocate(1024);

    Pipe.SinkChannel sinkChannel = pipe.sink();
    buf.put(&quot;通过单向管道发送数据&quot;.getBytes());
    buf.flip();
    sinkChannel.write(buf);

    //3. 读取缓冲区中的数据
    Pipe.SourceChannel sourceChannel = pipe.source();
    buf.flip();
    int len = sourceChannel.read(buf);
    System.out.println(new String(buf.array(), 0, len));

    sourceChannel.close();
    sinkChannel.close();
}
</code></pre>

<h2><span id='8'>nio2</span></h2>
<p><strong>自动资源管理</strong></p>
<pre><code>//自动资源管理：自动关闭实现 AutoCloseable 接口的资源
@Test
public void test8(){
    try( //try部分创建的流对象需要实现AutoCloseable接口
      FileChannel inChannel = FileChannel.open(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ); 
      FileChannel outChannel = FileChannel.open(Paths.get(&quot;2.jpg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE)){
       // 在下面的{}读写代码块执行完后会自动关闭流
        ByteBuffer buf = ByteBuffer.allocate(1024);
        inChannel.read(buf);    
    }catch(IOException e){

    }
}
</code></pre>

<hr />
<p><strong>Files</strong></p>
<pre><code>/*
    【Files常用方法：用于操作内容】
        SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。
        DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录
        InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象
        OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象
 */
@Test
public void test7() throws IOException{
    SeekableByteChannel newByteChannel = Files.newByteChannel(Paths.get(&quot;1.jpg&quot;), StandardOpenOption.READ);

    DirectoryStream&lt;Path&gt; newDirectoryStream = Files.newDirectoryStream(Paths.get(&quot;e:/&quot;));

    for (Path path : newDirectoryStream) {
        System.out.println(path);
    }
}

/*
    【Files常用方法：用于判断】
        boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
        boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
        boolean isExecutable(Path path) : 判断是否是可执行文件
        boolean isHidden(Path path) : 判断是否是隐藏文件
        boolean isReadable(Path path) : 判断文件是否可读
        boolean isWritable(Path path) : 判断文件是否可写
        boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
        public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption... options) : 获取与 path 指定的文件相关联的属性。
 */
@Test
public void test6() throws IOException{
    Path path = Paths.get(&quot;e:/nio/hello7.txt&quot;);
    //System.out.println(Files.exists(path, LinkOption.NOFOLLOW_LINKS));

    BasicFileAttributes readAttributes = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
    System.out.println(readAttributes.creationTime());
    System.out.println(readAttributes.lastModifiedTime());

    DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);

    fileAttributeView.setHidden(false);
}

/*
    【Files常用方法：】
        Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
        Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录
        Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件
        void delete(Path path) : 删除一个文件
        Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置
        long size(Path path) : 返回 path 指定文件的大小
 */
@Test
public void test5() throws IOException{
    Path path1 = Paths.get(&quot;e:/nio/hello2.txt&quot;);
    Path path2 = Paths.get(&quot;e:/nio/hello7.txt&quot;);

    System.out.println(Files.size(path2));

//  Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);
}

@Test
public void test4() throws IOException{
    Path dir = Paths.get(&quot;e:/nio/nio2&quot;);
    //Files.createDirectory(dir);

    Path file = Paths.get(&quot;e:/nio/nio2/hello3.txt&quot;);
//  Files.createFile(file);

    Files.deleteIfExists(file);
}

@Test
public void test3() throws IOException{
    Path path1 = Paths.get(&quot;e:/nio/hello.txt&quot;);
    Path path2 = Paths.get(&quot;e:/nio/hello2.txt&quot;);

    Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);
}
</code></pre>

<hr />
<p><strong>Paths接口获取Path对象</strong></p>
<pre><code>/*
    Paths 提供的 get() 方法用来获取 Path 对象：
        Path get(String first, String … more) : 用于将多个字符串串连成路径。
    Path 常用方法：
        boolean endsWith(String path) : 判断是否以 path 路径结束
        boolean startsWith(String path) : 判断是否以 path 路径开始
        boolean isAbsolute() : 判断是否是绝对路径
        Path getFileName() : 返回与调用 Path 对象关联的文件名
        Path getName(int idx) : 返回的指定索引位置 idx 的路径名称
        int getNameCount() : 返回Path 根目录后面元素的数量
        Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径
        Path getRoot() ：返回调用 Path 对象的根路径
        Path resolve(Path p) :将相对路径解析为绝对路径
        Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象
        String toString() ： 返回调用 Path 对象的字符串表示形式
 */
@Test
public void test2(){
    Path path = Paths.get(&quot;e:/nio/hello.txt&quot;);

    System.out.println(path.getParent());
    System.out.println(path.getRoot());

//      Path newPath = path.resolve(&quot;e:/hello.txt&quot;);
//      System.out.println(newPath);

    Path path2 = Paths.get(&quot;1.jpg&quot;);
    Path newPath = path2.toAbsolutePath();
    System.out.println(newPath);

    System.out.println(path.toString());
}

@Test
public void test1(){
    Path path = Paths.get(&quot;e:/&quot;, &quot;nio/hello.txt&quot;);

    System.out.println(path.endsWith(&quot;hello.txt&quot;));
    System.out.println(path.startsWith(&quot;e:/&quot;));

    System.out.println(path.isAbsolute());
    System.out.println(path.getFileName());

    for (int i = 0; i &lt; path.getNameCount(); i++) {
        System.out.println(path.getName(i));
    }
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
