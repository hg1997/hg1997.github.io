<!DOCTYPE html>
<html>
<head>
<title>mysql笔记</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>数据库笔记</h1>
<ul>
<li><a href="#zaji">杂记</a></li>
<li><a href="#delete">删除mysql</a></li>
<li>
<a href="#1.">1. 数据库概念</a>
<ul>
<li><a href="#1.1">1.1 什么是数据库</a></li>
<li><a href="#1.2">1.2 数据库发展历程</a></li>
<li><a href="#1.3">1.3 常见的数据库</a></li>
<li><a href="#1.4">1.4 理解数据库</a></li>
</ul>
</li>
<li>
<a href="#2.">2. sql概述</a>
<ul>
<li><a href="#2.1">2.1 什么是sql</a></li>
<li><a href="#2.2">2.2 mysql语法要求</a></li>
<li>
<a href="#2.3">2.3 sql语句 </a>
<ul>
<li><a href="#2.3.1">2.3.1 DDL</a></li>
<li><a href="#2.3.2">2.3.2 DML</a></li>
<li><a href="#2.3.3">2.3.3 DCL</a></li>
<li><a href="#2.3.4">2.3.4 DQL</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#3.">3. 完整性约束</a>
<ul>
<li><a href="#3.1">3.1 主键</a></li>
<li><a href="#3.2">3.2 主键自增长</a></li>
<li><a href="#3.3">3.3 外键</a></li>
<li><a href="#3.4">3.4 表与表之间的关系</a></li>
</ul>
</li>
<li>
<a href="#4.">4. 编码</a>
<ul>
<li><a href="#4.1">4.1 查看编码</a></li>
<li><a href="#4.2">4.2 设置编码</a></li>
</ul>
</li>
<li>
<a href="#5.">5. 数据库的备份与恢复</a>
<ul>
<li><a href="#5.1">5.1 生成sql脚本</a></li>
<li><a href="#5.2">5.2 执行sql脚本</a></li>
</ul>
</li>
<li>
<a href="#6.">6. 多表查询</a>
<ul>
<li><a href="#6.1">6.1 合并结果集</a></li>
<li>
<a href="#6.2">6.2 连接查询</a>
<ul>
<li><a href="#6.2.1">6.2.1 内连接</a></li>
<li><a href="#6.2.2">6.2.2 外连接</a></li>
</ul>
</li>
<li><a href="#6.3">6.3 子查询</a></li>
<li>
<a href="#7.">7. 视图</a>
<ul>
<li><a href="#7.1">7.1 创建视图</a> </li>
<li><a href="#7.2">7.2 查看视图</a></li>
<li><a href="#7.3">7.3 视图的执行</a></li>
<li><a href="#7.4">7.4 修改视图</a></li>
<li><a href="#7.5">7.5 删除视图</a></li>
<li><a href="#7.6">7.6 新增数据视图</a></li>
<li><a href="#7.7">7.7 删除视图</a></li>
<li><a href="#7.8">7.8 修改视图</a></li>
<li><a href="#7.9">7.9 视图算法</a></li>
</ul>
</li>
<li>
<a href="#8.">8. 触发器</a>
<ul>
<li><a href="#8.1">8.1 创建触发器</a></li>
<li><a href="#8.2">8.2 查看触发器</a> </li>
<li><a href="#8.3">8.3 修改触发器（先删除，再新增）</a> </li>
<li><a href="#8.4">8.4 触发器的记录</a> </li>
</ul>
</li>
<li><a href="#9.">9. 代码执行结构</a></li>
<li><a href="#10.">10. 函数</a></li>
<li><a href="#11.">11. 存储过程</a></li>
</ul>
</li>
</ul>
<h2><span id="zaji">杂记<span></h2>
<p><img src="https://i.imgur.com/ELjDVFD.jpg" /></p>
<hr />
<pre><code>停止MySQL
1 添加删除程序中卸载MySQL
2 到安装目录删除MySQL
3 删除：C:\Documents and Settings\All Users\Application Data\MySQL
  C:\ProgramData\MySQL
4 查看注册表：
regedit
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services
搜索mysql，找到一律干掉！
</code></pre>

<hr />
<ul>
<li>mysql的数据存储目录：C:\Documents and Settings\All Users\Application Data\MySQL</li>
</ul>
<hr />
<ul>
<li>
<p>sql的数据类型</p>
<ul>
<li><strong>三大类：【数值】 【字符串】【日期】</strong></li>
<li>
<p><img src="https://i.imgur.com/pgEyh4a.jpg" /></p>
</li>
<li>
<p>int：整型</p>
</li>
<li>double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为   	999.99；</li>
<li>decimal：泛型型，在表单钱方面使用该类型，因为不会出现精度缺失问题；</li>
<li>
char：固定长度字符串类型；
<ul>
<li><font color='red'>char(4) &emsp; 存储AB：3*4=12字节  &emsp; 存储A：3*4=12字节</font></li>
</ul>
</li>
<li>
varchar：可变长度字符串类型；
<ul>
<li><font color='red'>varchar(4) &emsp;存储AB：3*2+1=7字节 &emsp; 存储A：3*1+1=4字节</font></li>
</ul>
</li>
<li>text：字符串类型；</li>
<li>blob：字节类型；</li>
<li>date：日期类型，格式为：<strong>yyyy-MM-dd</strong>；</li>
<li>time：时间类型，格式为：<strong>hh:mm:ss</strong>；</li>
<li>timestamp：时间戳类型；<strong>yyyy-MM-dd hh:mm:ss</strong> <font color='red'>操作该行数据后时间会自动改变为修改数据时的时间</font></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
开启与关闭mysql服务器
<ul>
<li><code>net start mysql</code></li>
<li><code>net stop mysql</code></li>
<li>开启的是服务器端的mysql -- &gt; <font color='red'><strong>mysqld.exe</strong></font></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
客户端登陆
<ul>
<li><code>mysql [-h localhost -p 3306] -u root -p 123</code></li>
<li>登陆成功后启动一个客户端程序--&gt; <font color='red'><strong>mysql.exe</strong></font></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li><code>show databases</code> &emsp;&emsp;&emsp; 查看所有数据库</li>
<li>
<p><code>use 数据库名</code>    &emsp;&emsp;&emsp;&emsp; 切换到指定数据库</p>
</li>
<li>
<p><code>show tables</code>   &emsp;&emsp;&emsp;&emsp;查看指定数据库有哪些表</p>
</li>
</ul>
<hr />
<ul>
<li>
蠕虫复制：create table table_name like 数据库名.表名
<ul>
<li><code>create table stu2 like shool.stu;</code></li>
</ul>
</li>
<li>
蠕虫复制数据
<ul>
<li><code>insert into stu2 select * from stu;</code></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
单行注释（2种）
<ul>
<li>-- xxx</li>
<li>#  xxxx</li>
</ul>
</li>
<li>
多行注释
<ul>
<li>/* xxxx */</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
truncate 表名
<ul>
<li>原理是先删除表，再创建表(清空所有数据)</li>
<li><strong>主键恢复从0开始</strong></li>
<li>不可回滚</li>
</ul>
</li>
<li>
delete from 表名
<ul>
<li>删除表中的数据下次插入后<strong>主键接着上次开始往后计数</strong></li>
<li>可回滚</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
mysql<strong>默认开启事务</strong>
<ul>
<li>mysql每执行一条语句都是一个默认的事务</li>
<li>查看 ：<code>Show variables like 'autocommit';</code></li>
<li>设置关闭：<code>set autocommit = off/0;</code></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
mysql变量 --&gt; <strong>系统变量+自定义变量</strong>
<ul>
<li>查看系统的全部变量： <code>show variables</code> </li>
<li>查看系统变量(select @@变量名)：<code>select @@sql_model</code></li>
<li>
设置系统变量（set 变量名 = 值）
<ul>
<li><code>set sql_model = xxxxx</code></li>
<li><code>set @@sql_model = xxxxx</code> &emsp;&emsp;&emsp;&emsp; 会话级设置</li>
<li><code>set global sql_model = xxxxx</code> &emsp;&emsp;  全局设置</li>
</ul>
</li>
<li>
【设置+查看】 自定义变量<font color='red'>自定义变量前加“@”用于区分</font>
<ul>
<li>
设置
<ul>
<li>【方式1】set @变量名 = 值</li>
<li>【方式1】的等同 == &gt; set @变量名 := 值</li>
<li>【方式2】select xx into @变量名</li>
<li>【方式2】的等同 select @变量名 := 值</li>
</ul>
</li>
<li>
查看 
<ul>
<li>select @变量名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id='delete'>删除mysql<span></h2>
<pre><code>1添加删除程序中卸载MySQL
2到安装目录删除MySQL
3删除：C:\Documents and Settings\All Users\Application Data\MySQL
    C:\ProgramData\MySQL
4查看注册表：
regedit
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services
搜索mysql，找到一律干掉！
</code></pre>

<h2><span id='1.'>1.数据库概念<span></h2>
<h3><span id='1.1'>1.1 什么是数据库</spn></h3>
<ul>
<li><strong>存储</strong>和<strong>管理</strong>数据的仓库</li>
<li>
数据库的优点
<ul>
<li>可存储大量数据；</li>
<li>方便检索；</li>
<li>保持数据的一致性、完整性；</li>
<li>安全，可共享；</li>
<li>通过组合分析，可产生新数据。</li>
</ul>
</li>
</ul>
<h3><span id='1.2'>1.2 数据库发展历程</spn></h3>
<ul>
<li>没有数据库，使用磁盘文件存储数据；</li>
<li>层次结构模型数据库；</li>
<li>网状结构模型数据库；</li>
<li><font color='red'>关系结构模型数据库：使用二维表格来存储数据；</font></li>
<li>关系-对象模型数据库；</li>
</ul>
<h3><span id='1.3'>1.3 常见数据库</spn></h3>
<ul>
<li>Oracle（<strong>神喻</strong>）：甲骨文（最高！）；</li>
<li>DB2：IBM；</li>
<li>SQL Server：微软；</li>
<li>Sybase：赛尔斯；</li>
<li>MySQL：甲骨文；</li>
</ul>
<h3><span id='1.4'>1.4 理解数据库</spn></h3>
<ul>
<li>关系型数据库管理系统(<strong>RDBMS</strong>) = 管理员 + Databases</li>
</ul>
<p><img src="https://i.imgur.com/54eTKn5.png" alt="RDBMS" /></p>
<ul>
<li>数据库（database）= n 个table</li>
</ul>
<p><img src="https://i.imgur.com/k0wvFDo.png" alt="table" /></p>
<ul>
<li>table = 表结构 + 表数据</li>
</ul>
<h2><span id='2.'>2. sql概述<span></h2>
<h3><span id='2.1'>2.1 什么是sql</spn></h3>
<blockquote>
<p>结构化查询语言</p>
<p>操作所有关系型数据库，同时各个数据库之间存在细小差异<strong>（方言）</strong></p>
<p>如mysql的limit语句 </p>
</blockquote>
<h3><span id='2.2'>2.2 mysql语法要求</spn></h3>
<ul>
<li>可以单行多行书写，<strong>以分号结尾</strong></li>
<li>
关键字不区分大小写，建议大写
<ul>
<li><code>select * from stu where name =</code><strong>'ABC'</strong><code>;</code></li>
<li>等同</li>
<li><code>select * from stu where name =</code><strong>'abc'</strong><code>;</code></li>
</ul>
</li>
</ul>
<h3><span id='2.3'>2.3 sql语句</spn></h3>
<h4><span id='2.3.1'>DDL</spn></h4>
<p>数据库定义语言，用来定义【数据库】,【表】,【操作表的列】</p>
<blockquote>
<p>操作数据库</p>
</blockquote>
<pre><code>* 创建数据库
    * `CREATE DATABASE [IF NOT EXISTS] mydb1；`
* 删除数据库
    * `DROP DATABASE [IF EXISTS] mydb1；`
* 改变数据库的编码
    * `ALTER DATABASE mydb1 CHARACTER SET utf8;`  **注意是 utf8**
</code></pre>

<blockquote>
<p>操作表</p>
</blockquote>
<pre><code>创建表
     create table stu(
        name varchar(20),
        age int
      ); 

删除表
    drop table stu;

查看表结构
    desc stu;

查看指定表的创建语句
    show create table stu;
</code></pre>

<blockquote>
<p>改动表</p>
</blockquote>
<pre><code>改动表名：
    alter table stu rename to student;
-----------------------------------------
添加列
    alter table stu addr varchar(100);
删除列
    alter table stu drop name;  //删除name列
修改列名：
    alter table stu change name username varchar(100);//name修改为username
修改列类型
    alter table stu modify name varchar(50);   //name类型修改为varchar(50)
修改列顺序
    alter table stu modify name varchar(50) first； //将name字段设置为第一个字段
    alter table stu modify name varchar(50) after age; //name字段放在age之后
</code></pre>

<h4><span id='2.3.2'>DML</spn></h4>
<p>数据库管理语言，用于操作数据库的数据记录</p>
<blockquote>
<p>插入数据</p>
</blockquote>
<pre><code>显式指定字段：
INSERT INTO stu(sid, sname,age,gender) VALUES('s_1001', 'zhangSan', 23, 'male');

未显式指定字段：  要求插入数据顺序和字段顺序一致!!!
INSERT INTO stu VALUES('s_1002', 'liSi', 32, 'female');
</code></pre>

<blockquote>
<p>修改数据</p>
</blockquote>
<pre><code>update stu set name = 'zhangsan';  //不需要`table`这个关键字
</code></pre>

<blockquote>
<p>删除数据</p>
</blockquote>
<pre><code>delete from stu where name = 'zhangsan';  //不需要`table`这个关键字
truncate table stu;                       //清空表数据，效率高一些
</code></pre>

<h4><span id='2.3.3'>DCL</spn></h4>
<p>数据库控制语言，用于定义访问权限和安全级别</p>
<blockquote>
<p>创建用户</p>
</blockquote>
<pre><code>CREATE USER user1@localhost IDENTIFIED BY ‘123’; //只能在本机登录，密码123
CREATE USER user2@’%’ IDENTIFIED BY ‘123’;       //任何ip可登录，密码123
</code></pre>

<blockquote>
<p>赋予权限</p>
</blockquote>
<pre><code>GRANT 权限1, … , 权限n ON 数据库.* TO 用户名

GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON mydb1.* TO user1@localhost;   //将【部分权限】给user1,可操作mydb1的【全部表】
GRANT ALL ON mydb1.* TO user2@localhost;  //【全部权限】 --&gt; mydb1的【全部表】
</code></pre>

<blockquote>
<p>撤销权限</p>
</blockquote>
<pre><code>REVOKE权限1, … , 权限n ON 数据库.* FORM 用户名

REVOKE CREATE,ALTER,DROP ON mydb1.* FROM user1@localhost;
</code></pre>

<blockquote>
<p>查看用户权限</p>
</blockquote>
<pre><code>SHOW GRANTS FOR 用户名

SHOW GRANTS FOR user1@localhost;
</code></pre>

<blockquote>
<p>删除用户</p>
</blockquote>
<pre><code>DROP USER 用户名

DROP USER user1@localhost;
</code></pre>

<blockquote>
<p>修改密码</p>
</blockquote>
<pre><code>UPDATE USER SET PASSWORD=PASSWORD(‘密码’) WHERE User=’用户名’ and Host=’IP’;
FLUSH PRIVILEGES;

UPDATE USER SET PASSWORD=PASSWORD('1234') WHERE User='user2' and Host=’localhost’;  
FLUSH PRIVILEGES;
</code></pre>

<h4><span id='2.3.4'>DQL</spn></h4>
<p>数据库查询语言</p>
<blockquote>
<p>查询顺序</p>
</blockquote>
<pre><code>SELECT selection_list /*要查询的列名称*/
FROM table_list /*要查询的表名称*/
WHERE condition /*行条件*/
GROUP BY grouping_columns /*对结果分组*/
 HAVING condition /*分组后的行条件*/
 ORDER BY sorting_columns /*对结果分组*/
 LIMIT offset_start, row_count /*结果限定*/
</code></pre>

<blockquote>
<p>条件查询</p>
</blockquote>
<ul>
<li>后接where子句</li>
<li>
在<strong>where子句后使用</strong>运算符
<ul>
<li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=</li>
<li>BETWEEN…AND</li>
<li>IN(set)</li>
<li>IS NULL</li>
<li>AND</li>
<li>OR</li>
<li>NOT</li>
</ul>
</li>
</ul>
<p>查询性别非男的学生记录</p>
<pre><code>    SELECT * FROM stu
    WHERE【gender!='male'】;
    或者
    SELECT * FROM stu
    WHERE【 gender&lt;&gt;'male'】;
    或者
    SELECT * FROM stu
    WHERE【NOT gender='male'】;
</code></pre>

<p>查询姓名不为null的学生记录</p>
<pre><code>SELECT * FROM stu
WHERE【 NOT sname IS NULL】;
或者
SELECT * FROM stu
WHERE 【sname IS NOT NULL】;
</code></pre>

<blockquote>
<p>模糊查询</p>
</blockquote>
<pre><code>where name like '__a'  //一个下划线代表一个字符
where name like '%a%'  //一个%匹配0-n个字符
</code></pre>

<blockquote>
<p>字段控制查询</p>
</blockquote>
<pre><code>去除重复行
SELECT DISTINCT sal FROM emp;
</code></pre>

<hr />
<pre><code>列相加
SELECT sal+IFNULL(comm,0) FROM emp; 
//使用了IFNULL函数，common列为null，则作为数字0
</code></pre>

<hr />
<pre><code>给查询列取别名
select name [AS] username from stu;
// name的别名为username,【as可省略】
</code></pre>

<blockquote>
<p>排序查询</p>
</blockquote>
<pre><code>默认：升序 ESC  [降序DESC]
order by age;   //默认升序
order by age desc; //降序排序
order by sal desc,id asc;   //月薪降序派，月薪相同时id升序排
</code></pre>

<blockquote>
<p>聚合查询</p>
</blockquote>
<pre><code>count()

select count(*) from stu; //查询非null行数
select count(score) from stu; //查询scor为非null的行数
---------------------------------------------------
sum() avg()

SELECT SUM(sal) FROM emp;
SELECT AVG(sal) FROM emp;
---------------------------------------------------
max() min()

SELECT MAX(sal), MIN(sal) FROM emp;
</code></pre>

<blockquote>
<p>分组查询</p>
</blockquote>
<p><font color='red'>
 &emsp; &emsp;分组一定得使用到聚合函数，因为按照字段分组后出现几个块，只能获取这几个块的总体聚合的信息 <br />
 </font></p>
<p><img src="https://i.imgur.com/9UEDe5S.png" /></p>
<pre><code>SELECT NAME,SUM(mark) FROM score GROUP BY NAME; 
//按照name字段分组，显示分组后的各个name项，以及其对应的总分【本例聚合函数体现在sum（）求总分】
</code></pre>

<p><img src="https://i.imgur.com/XA39HJ1.png" /></p>
<h4>having子句</h4>
<pre><code>SELECT deptno, SUM(sal)FROM emp
GROUP BY deptno
HAVING SUM(sal) &gt; 9000;
</code></pre>

<p><strong>&gt; 不满足where条件的数据不参与分组</strong></p>
<p><strong>&gt; having子句是对分组后的数据进行过滤</strong></p>
<blockquote>
<p>分页查询</p>
</blockquote>
<pre><code>SELECT * FROM emp LIMIT 0, 5;
// 0 ：起始数据行  5：一页5条数据
// 角标从0开始，0表示第一条数据

SELECT * FROM emp LIMIT 5;
//不指定起始角标，默认为0
</code></pre>

<h2><span id='3.'>3. 完整性约束</spn></h2>
<h3><span id='3.1'>3.1 主键（primary key）</spn></h3>
<p><strong>非空 + 唯一（不可重复）+ 可被外部引用</strong> </p>
<pre><code>创建表时指定:

//在定义列时指定
CREATE TABLE stu(
sid     CHAR(6) PRIMARY KEY,
sname   VARCHAR(20),
age     INT,
gender  VARCHAR(10) 
);

//在定义完列后指定
CREATE TABLE stu(
sid     CHAR(6),
sname   VARCHAR(20),
age     INT,
gender  VARCHAR(10),
PRIMARY KEY(sid)
);
</code></pre>

<hr />
<pre><code>修改表时指定：
ALTER TABLE stu ADD PRIMARY KEY(sid);
</code></pre>

<hr />
<pre><code>删除主键：
alter table stu drop primary key;
</code></pre>

<h3><span id='3.2'>3.2 主键自增长</spn></h3>
<pre><code>创建表时指定：
create table stu(
 age int primary key auto_increment
);

修改表时设置主键自增长：
alter table stu change age age int auto_increment;

修改表时删除主键自增长：
alter tavble stu change age age int;
</code></pre>

<h3><span id='3.3'>3.3 外键</spn></h3>
<p><strong>&emsp;&emsp;外键是另一张表的主键</strong></p>
<p><strong>&emsp;&emsp;外键可以为null（没有上级）</strong></p>
<p><strong>&emsp;&emsp;外键可以重复（多个员工同一个上级）</strong></p>
<pre><code>创建老师teacher表：

create table teacher(
t_id int primary key auto_increment
);

创建学生表，指定学生表中的外键与老师表中的主键t_id相关联：
create table stu(
s_id int primary key auto_increment,
t_id int,
constraint fk_stu_tea foreign key(t_id) references teacher(t_id)    
);

//constraint fk_stu_tea foreign key(t_id) references teacher(t_id)
             [外键名字]          [本表中的外键列]     [其他关联表中需关联的主键]
</code></pre>

<hr />
<pre><code>修改表时添加外键
alter table stu add constraint fk_stu_tea foreign key(t_id) references teacher(t_id);
</code></pre>

<hr />
<pre><code>修改表时删除外键
alter table stu drop foreign key fk_stu_tea;
</code></pre>

<h3><span id='3.4'>3.4 表与表之间关系</spn></h3>
<ul>
<li>
一对一
xxxx
</li>
<li>
<p>一对多</p>
<ul>
<li>&quot;一&quot;方为主表，&quot;多&quot;方为从表，多方引用一方（多个学生对应一个老师）</li>
<li>在多方建立外键，参照一方中的主键</li>
</ul>
</li>
<li>
<p>多对多</p>
<ul>
<li>通过第三张表建立两个外键，这两个外键各自引用存在多对多关系的两张表。</li>
</ul>
</li>
</ul>
<h2><span id='4.'>4. 编码</spn></h2>
<h3><span id='4.1'>4.1 查看编码</spn></h3>
<p><code>show variables like 'character_set%'</code></p>
<p><img src="https://i.imgur.com/f7yTzWe.png" /></p>
<ul>
<li>character_set_client：服务器会使用该编码来【解码】客户端发送来的数据</li>
<li>character_set_results：服务器使用该编码对查询返回给客户端的数据进行【编码】</li>
</ul>
<h3><span id='4.2'>4.2 设置编码</spn></h3>
<ul>
<li>
由于在dos下只能gbk,因此改变上述的变量为gbk,解决dos下乱码问题
<ul>
<li>set character<em>set</em>client=gbk; </li>
<li>set character<em>set</em>results=gbk; </li>
</ul>
</li>
</ul>
<p><strong><font color='red'>上述的修改是会话级修改，要想一劳永逸需要在my.ini的配置文件中修改</font></strong>
<img src="https://i.imgur.com/nBUWdlr.jpg" /></p>
<hr />
<pre><code>character_set_connection：通过该编码与client一致！该编码不会导致乱码！当执行的是查询语句时，客户端发送过来的数据会先转换成connection指定的编码。但只要客户端发送过来的数据与client指定的编码一致，那么转换就不会出现问题；

character_set_database：数据库默认编码，在创建数据库时，如果没有指定编码，那么默认使用database编码；

character_set_server：MySQL服务器默认编码；
</code></pre>

<p><font color='red'>快捷设置方式：</font></p>
<p><code>set names gbk;</code>  
</p>
<p><strong>针对&emsp;character_set_client &emsp;character_set_results&emsp;character_set_connection&emsp;进行统一快捷设置</strong></p>
<h2><span id='5.'>5. 数据库的备份与恢复</spn></h2>
<h3><span id='5.1'>5.1 s生成sql脚本</spn></h3>
<p><code>mysqldump –u用户名 –p密码 数据库名&gt;生成的脚本文件路径</code></p>
<p><code>mysqldump -u root -p 123 mydb1&gt;c:/mydb1.sql</code></p>
<ul>
<li>备份之前无需登录</li>
<li>不包括创建数据库的语句，只包含了数据库表的数据，在还原时需要手动创建数据库后再将这些信息导入</li>
</ul>
<p><font color='red'>备份所有数据库</font></p>
<p><code>mysqldump -u root -p 123 --all-databases &gt; c:/mydb.sql</code></p>
<h3><span id='5.2'>5.2 执行sql脚本</spn></h3>
<p><code>source c:/mydb1.sql</code></p>
<ul>
<li>方法一：需要登录后进入指定的数据库后再执行</li>
</ul>
<p><code>mysql -uroot -p123 mydb1&lt;c:/mydb1.sql</code></p>
<ul>
<li>方法二：这种方式无需登录</li>
</ul>
<h2><span id='6.'>6. 多表查询</spn></h2>
<h3><span id='6.1'>6.1 合并结果集</spn></h3>
<ul>
<li>就是将两个select语句的结果合并到一起</li>
<li><strong>注意：合并的两个查询结果的【列数】，【列类型】要一致</strong></li>
</ul>
<hr />
<pre><code>union : 去除重复行
SELECT * FROM t1 【UNION】SELECT * FROM t2;
</code></pre>

<p><img src="https://i.imgur.com/fIf6kJN.jpg" /></p>
<hr />
<pre><code>union all: 不去除重复行
SELECT * FROM t1 【UNION  ALL】 SELECT * FROM t2;
</code></pre>

<p><img src="https://i.imgur.com/Nr0aBoj.jpg" /></p>
<h3><span id='6.2'>6.2 连接查询</spn></h3>
<ul>
<li>多个表之间进行连接查询，产生笛卡儿积</li>
<li>通过主外键关联，共性字段匹配去除无用笛卡儿积</li>
</ul>
<h4><span id='6.2.1'>6.2.1 内连接</spn></h4>
<p><strong>&emsp;&emsp;查询的结果一定是严格满足查询条件的</strong></p>
<pre><code>select * from stu,score where stu.sid = score = sid;
其实这种内连接是mysql的方言
---------------------------------------------------
标准sql的内连接：
select * from stu 【inner】 join score 【【on】】】 stu.sid = score.sid;
&gt; inner可以省略
&gt; 使用的是 on 而不是 where
</code></pre>

<h4><span id='6.2.2'>6.2.2 外连接</spn></h4>
<p><strong>&emsp;&emsp;查询的结果并非严格满足查询条件</strong></p>
<blockquote>
<p>左外连接</p>
</blockquote>
<p><font color='red'>以左表为主，不满足条件的左表数据项在右边位置显示null</font></p>
<pre><code>SELECT * FROM emp e 【LEFT OUTER JOIN】 dept d ON e.deptno=d.deptno;
</code></pre>

<p><img src="https://i.imgur.com/ebm2Cm7.jpg" /></p>
<blockquote>
<p>右外连接</p>
</blockquote>
<p><font color='red'>以右表为主，不满足条件的左表数据项在左边位置显示null</font></p>
<pre><code>SELECT * FROM emp e 【RIGHT OUTER JOIN】 dept d ON e.deptno=d.deptno;
</code></pre>

<p><img src="https://i.imgur.com/8irYAOU.jpg" /></p>
<blockquote>
<p>全外连接</p>
</blockquote>
<p><font color='red'>mysql不支持，可以通过union合并【左外连接】和【右外连接】的结果集及来模拟</font></p>
<p><code>SELECT * FROM emp e 【LEFT OUTER JOIN】 dept d ON e.deptno=d.deptno;</code>  &emsp;//左外</p>
<p><strong>union</strong></p>
<p><code>SELECT * FROM emp e 【RIGHT OUTER JOIN】 dept d ON e.deptno=d.deptno;</code>  &emsp;//右外</p>
<h3><span id='6.3'>6.3 子查询</spn></h3>
<blockquote>
<p>子查询出现在where后 <strong>作为查询的条件</strong></p>
</blockquote>
<ul>
<li>
单行单列
<ul>
<li><code>SELECT * FROM emp WHERE sal &gt; (SELECT sal FROM emp WHERE ename='甘宁')；</code></li>
</ul>
</li>
<li>
单行多列
<ul>
<li><code>SELECT * FROM emp WHERE (job,sal) IN (SELECT job,sal FROM emp WHERE ename='殷天正');</code></li>
</ul>
</li>
<li>
多行单列
<ul>
<li><code>SELECT * FROM emp WHERE sal &gt; ALL (SELECT sal FROM emp WHERE deptno=30);</code></li>
</ul>
</li>
</ul>
<p><strong><font color='red'>子查询出现在where后时，还可以使用以下关键字：</font></strong></p>
<p><strong><font color='red'>主要针对【多行单列】</font></strong></p>
<pre><code>【any】  select * from 表名 where 字段 &gt; any(select 单个字段 from xxx where xxx);    // 大于最小值
【all】  select * from 表名 where 字段 &gt; all(select 单个字段 from xxx where xxx);    //大于最大值
【in】   select * from 表名 where 字段 in (select 单个字段 from xxx where xxx);   
【exists】  select * from emp where exists (select 单个字段 from xxx where xxx);
</code></pre>

<hr />
<blockquote>
<p>子查询出现在from后 <strong>作为查询的新表</strong></p>
</blockquote>
<pre><code>SELECT e.ename, e.sal, d.dname, d.loc 
FROM emp e, (SELECT dname,loc,deptno FROM dept) d    //子查询作为新表
WHERE e.deptno=d.deptno AND e.empno=1006
</code></pre>

<h2><span id='7.'>7.视图<span></h2>
<ul>
<li>是一个&quot;虚表&quot;</li>
<li>数据来源是&quot;基表&quot;</li>
</ul>
<blockquote>
<p><strong>视图的意义</strong></p>
</blockquote>
<ul>
<li>简化查询语句：将经常使用的查询定义为视图</li>
<li>安全性：只能进行查询和修改，限定到特定数据库</li>
<li>逻辑数据独立性</li>
</ul>
<hr />
<ol>
<li>视图可以节省SQL语句: 将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li>
<li>数据安全: 视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li>
<li>视图往往是在大项目中使用, 而且是多系统使用: 可以对外提供有用的数据, 但是隐藏关键(无用)的数据: 数据安全</li>
<li>视图可以对外提供友好型: 不同的视图提供不同的数据, 对外好像专门设计</li>
<li>视图可以更好(容易)的进行权限控制</li>
</ol>
<h3><span id='7.1'>7.1 创建视图<span></h3>
<p><font color='red'><strong>视图一旦创建会在c盘的数据库文件中产生一个frm结构文件</strong></font></p>
<pre><code>create [or replace] [algorithm ={undefiend| temptable | merge}]
view 视图名 [自定义对应的列名]
as select statement
[with [cascaded | local] check option]  
</code></pre>

<ol>
<li>
<p>创建【单表视图	】</p>
<p><code>create view my_view as select * from stu;</code></p>
</li>
<li>
<p>创建【多表视图】</p>
<ul>
<li>通过多表查询完成</li>
<li><font color='red'>多表时不能有相同的字段重复的情况</font></li>
</ul>
<p><code>create view my_view as select * from a inner join b</code></p>
</li>
</ol>
<h3><span id='7.2'>7.2 查看视图<span></h3>
<ul>
<li>
<p>视图是一张虚表，所有用于表的的查看都使用于视图</p>
<p><code>show tables</code>   &emsp;&emsp;&emsp;&emsp;<strong>视图也作为表，和其他表一起显示出来</strong></p>
<p><code>desc 视图名</code></p>
<p><code>show create table[view] 视图名</code>  &emsp;&emsp;<strong>table关键字和view关键字都可以</strong></p>
</li>
</ul>
<h3><span id='7.3'>7.3 视图的执行<span></h3>
<p><code>select * from 视图名</code></p>
<ul>
<li>视图的执行本质就是对【封装的select语句】的执行</li>
</ul>
<h3><span id='7.4'>7.4 修改视图<span></h3>
<ul>
<li>
<p>视图本身不能修改，本质是修改视图的数据来源</p>
<p>方法1) <code>alter view 视图名 as select语句</code></p>
<p>方法2) <code>create or replace view 视图名 as select语句</code></p>
</li>
</ul>
<h3><span id='7.5'>7.5 删除视图<span></h3>
<p>&emsp;&emsp;<code>drop table[view] 视图名</code></p>
<h3><span id='7.6'>7.6 新增数据<span></h3>
<ul>
<li>多表视图不能新增数据</li>
<li>
可以向单表视图新增数据
<ul>
<li>但是视图中包含的字段必须有基表中所有不能为空(或者没有默认值)的字段</li>
<li>
向单表视图插入数据后，数据会存储到基表中
<ul>
<li><code>insert into 视图名 values（xxx）</code></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id='7.7'>7.7 删除数据<span></h3>
<ul>
<li>多表视图不能删除数据</li>
<li>
可以从单表视图删除数据
<ul>
<li>
单表视图删除数据后，基表也会删除
<ul>
<li>delete from 视图名 where xxx</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id='7.8'>7.8 更改数据<span></h3>
<ul>
<li>单表视图，多表视图，都可以更新数据，对基本产生影响</li>
<li>
更新限制: with check option
<ul>
<li>create view my_view as select * from student 【where age &gt; 30】 with check option</li>
<li>这样创建出来的视图不允许将age更改为&lt;30的数据，更改不成功的。</li>
</ul>
</li>
</ul>
<h3><span id='7.9'>7.9 视图算法<span></h3>
<p>视图算法: 系统对视图以及外部查询视图的Select语句的一种解析方式.</p>
<blockquote>
<p>视图算法分为三种</p>
</blockquote>
<ul>
<li>Undefined: 未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办</li>
<li>Temptable: 临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句</li>
<li>Merge: 合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态)</li>
</ul>
<blockquote>
<p>算法指定: 在创建视图的时候</p>
</blockquote>
<p><code>Create algorithm = 指定算法 view 视图名字 as select语句;</code></p>
<blockquote>
<p>视图算法选择</p>
</blockquote>
<p>如果视图的select语句中会包含一个查询子句, 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可).</p>
<h2><span id='8.'>8.触发器<span></h2>
<ul>
<li>
触发器: 
<ul>
<li>trigger, 事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行.</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
触发器: 事件类型, 触发时间, 触发对象
<ul>
<li>事件类型: 增删改, 三种类型insert,delete和update</li>
<li>触发时间: 前后: before和after</li>
<li>触发对象: 表中的每一条记录(行)</li>
</ul>
</li>
</ul>
<p><strong>一张表中只能拥有一种触发时间的一种类型的触发器: 最多一张表能有6个触发器</strong></p>
<h3><span id='8.1'>8.1 创建<span></h3>
<pre><code>Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束

Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row
Begin       -- 代表左大括号: 开始
-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号
End         -- 代表右带括号: 结束
</code></pre>

<hr />
<pre><code>如果触发器内部只有一条要执行的SQL指令, 可以省略大括号(begin和end)
Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row
一条sql语句
</code></pre>

<p><img src="https://i.imgur.com/KdcnEKz.png" /></p>
<h3><span id='8.2'>8.2 查看<span></h3>
<p><code>Show triggers [like ‘pattern’];</code></p>
<p><code>Show create trigger 触发器名字;</code></p>
<p>所有的触发器都会保存一张表中: Information_schema.triggers
<code>select * from Information_schema.triggers</code></p>
<h3><span id='8.3'>8.3 修改触发器（先删除，再新增）<span></h3>
<p><code>Drop trigger 触发器名字;</code></p>
<p><code>再新建</code></p>
<h3><span id='8.4'>8.4 触发器的记录<span></h3>
<ul>
<li>
触发器记录
<ul>
<li>不管触发器是否触发了,只要当某种操作准备执行, 系统就会将当前要操作的记录的当前状态和即将执行之后新的状态给分别保留下来, 供触发器使用: 其中, 要操作的当前状态保存到old中, 操作之后的可能形态保存给new.</li>
<li>Old代表的是旧记录,new代表的是新记录</li>
<li>删除的时候是没有new的; 插入的时候是没有old</li>
<li>Old和new都是代表记录本身: 任何一条记录除了有数据, 还有字段名字.</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>使用方式</p>
<p><code>old.字段名 / new.字段名(new代表的是假设发生之后的结果)</code></p>
</li>
</ul>
<p><img src="https://i.imgur.com/nYILqBQ.png" />
<img src="https://i.imgur.com/Z692TP1.png" /></p>
<h2><span id='9.'>9.代码执行结构<span></h2>
<ul>
<li>顺序</li>
<li>分支</li>
<li>循环</li>
</ul>
<blockquote>
<p>分支</p>
</blockquote>
<ul>
<li>mysql中只有if</li>
</ul>
<p><strong>基本语法</strong></p>
<pre><code>If  条件判断  then
-- 满足条件要执行的代码;
Else
-- 不满足条件要执行的代码;
End if;  【注意有个分号，不能写漏了！】
</code></pre>

<p><strong>举例</strong>
<img src="https://i.imgur.com/W5IsKMb.png" />
<img src="https://i.imgur.com/a2bCJns.png" /></p>
<hr />
<blockquote>
<p>循环</p>
</blockquote>
<ul>
<li>只有while循环，没有for循环</li>
<li>没有continue和break,但有对应的【iterate】和【leave】对应替换</li>
</ul>
<p><strong>语法</strong></p>
<pre><code>[循环标记:]While 条件判断 do
         -- 满足条件要执行的代码
         -- 变更循环条件
         [leave/iterate 循环标记]
         End while;   【注意有个分号，不能写漏了！】
</code></pre>

<h2><span id='10.'>10.函数<span></h2>
<blockquote>
<p>两类函数</p>
</blockquote>
<ul>
<li>系统定义好的函数</li>
<li>用户自定义函数</li>
</ul>
<p><font color='red'>函数是与某一数据库绑定的，在别的数据库不能使用，可以在别的数据库通过【数据库.函数名（）】调用</font></p>
<blockquote>
<p>函数的调用</p>
</blockquote>
<p><code>select 函数（xxx）</code></p>
<hr />
<blockquote>
<p>系统函数</p>
</blockquote>
<p><code>select substring('xx',from,length);</code></p>
<ul>
<li><font color='red'>mysql的角标【从1开始】</font></li>
</ul>
<p><code>select char_length('xx')</code></p>
<ul>
<li>字符长度</li>
</ul>
<p><code>select length('xx')</code></p>
<ul>
<li>字节长度</li>
</ul>
<p><code>select instr('父串'，'子串/字符')</code></p>
<ul>
<li>返回子串在父串中位置【从1开始】，【0表示不存在】</li>
</ul>
<p><code>select lpad('@en',20,'欢迎')</code></p>
<ul>
<li>将【'欢迎'】填充到指定的【20】个字符长度（即重复了10次）</li>
<li>@en变量变为了【欢迎欢迎欢迎欢迎欢迎欢迎欢迎欢迎欢迎欢迎】</li>
</ul>
<p><code>select insert(@en,3,3,'y')</code></p>
<ul>
<li>@en 为   hello world</li>
<li>从指定位置【3】开始，将后续【3】个连续的字符替换为y  
</li>
<li>he【llo】 world  == &gt;  hey world</li>
</ul>
<p><code>select strcmp('串1','串2')</code></p>
<ul>
<li>比较两个字符串大小，结果为 -1  0  1</li>
<li>不区分大小写  <code>select strcmp('abc','ABC')</code> 结果为0</li>
</ul>
<hr />
<blockquote>
<p>自定义函数</p>
</blockquote>
<pre><code>Create function  函数名([形参列表]) returns 数据类型 -- 规定要返回的数据类型
Begin
-- 函数体
-- 返回值: return 类型(指定数据类型);
End

//函数体和返回值只有一句话时【可以省略begin和end】
</code></pre>

<ul>
<li>
<p>定义</p>
<p><code>create function show() return int</code></p>
<p><code>return 100;</code></p>
</li>
<li>
<p>调用</p>
<p><code>select show()</code></p>
</li>
</ul>
<p><strong>查看函数</strong></p>
<p><code>show function status\G</code>   &emsp;&emsp;函数属于数据库，只有在对应的数据库可以使用
<code>show create function 函数名</code>  &emsp;&emsp;查看函数创建语句 </p>
<p><strong>修改函数（只能先删除，再新增）</strong></p>
<p><code>drop function 函数名</code></p>
<p><strong>作用域</strong></p>
<ul>
<li>
<p>全局变量</p>
<ul>
<li>可以在任何地方使用</li>
<li>使用set和@符号定义</li>
<li><code>set @username = 'zhangsan'</code></li>
</ul>
</li>
<li>
<p>局部变量：</p>
<ul>
<li>只能在函数内部使用</li>
<li>使用declare定义，无@符号</li>
<li><code>declare i int default 1</code></li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/lcjM8KX.png" /></p>
<p><strong>函数参数</strong></p>
<ul>
<li>定义函数时先写参数名，再写参数类型 <code>create function show(number int) .....</code></li>
<li><font color='red'>函数内部使用@定义的变量在函数外部也可以通过<code>select @xx</code>访问</font>
<img src="https://i.imgur.com/6nCgat8.png" /></li>
</ul>
<h2><span id='11.'>11.存储过程<span></h2>
<ul>
<li>也叫做【“过程”】</li>
<li>procedure，一种处理数据的方式</li>
<li>一种没有返回值的函数</li>
</ul>
<hr />
<p><strong>创建存储过程</strong></p>
<pre><code>Create procedure 过程名字([参数列表])
Begin
-- 过程体
End

//同样地，过程体只有一句话的时候可以【省略begin和end】
</code></pre>

<p><code>create procedure pro1()</code></p>
<p><code>select * from stu</code></p>
<p><strong>查看存储过程</strong></p>
<ul>
<li>查看函数的方式完全使用于存储过程，只是换成procedure关键字</li>
</ul>
<p><code>show procedure status [like pattern];</code> &emsp;&emsp;&emsp;查看所有存储过程</p>
<p><code>show create procedure 过程名\G</code>  &emsp;&emsp;&emsp;查看存储过程创建语句</p>
<p><strong>调用存储过程</strong></p>
<ul>
<li>因为没有返回值，不能使用select调用，select是针对函数的调用</li>
<li>
存储过程专用的调用关键字==》<code>call</code>
<ul>
<li><code>call pro1()</code></li>
</ul>
</li>
</ul>
<p><strong>修改存储过程（只能先删除，再新增）</strong></p>
<p><code>drop procedure 过程名</code></p>
<p><strong>存储过程的参数</strong></p>
<ul>
<li>
<p>参数的类型限定：</p>
<ul>
<li>
in
<ul>
<li>典型的值传递，传递到内部的改变对外部不产生影响</li>
<li>可以传递变量和常量</li>
</ul>
</li>
<li>
<p>out</p>
<ul>
<li>传递到内部的改变会对外部产生影响</li>
<li><font color='blue'><strong>只能传递变量</strong></font></li>
<li><font color='red'>传递到内部会被先清空变为null</font></li>
</ul>
</li>
<li>
<p>inout</p>
<ul>
<li>典型的引用传递，传递内部的改变会对外部产生影响</li>
<li><font color='blue'><strong>只能传递变量</strong></font></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>基本使用</p>
<p>Create procedure 过程名(【in 形参名字 数据类型】,【 out 形参名字 数据类型】,【inout 形参名字 数据类型】 )
<img src="https://i.imgur.com/jBkV8D1.png" /></p>
</li>
<li>
<p>关于内部改变影响外部变量</p>
<ul>
<li>存储过程对于变量的操作(返回)是滞后的: 是在存储过程调用结束的时候,才会重新将内部修改的值赋值给外部传入的全局变量.</li>
</ul>
<p><img src="https://i.imgur.com/JtfGqFY.png" /></p>
<ul>
<li>在调用完存储过程后，【out和inout会将内部的局部变量重写赋值给外部的全局变量】（这一步是隐式的），重新查看三个全局变量的值</li>
</ul>
<p><code>select @int_1,@int_2,@int_3</code></p>
<p>结果：a 100 1000</p>
</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
