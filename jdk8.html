<!DOCTYPE html>
<html>
<head>
<title>1.8笔记</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<ul>
<li><a href="#1.1">1.1 接口可有非抽象方法</a></li>
<li>
<a href="#1.2">1.2 lambda表达式</a>
<ul>
<li><a href="#1.2.1">1.2.1 举个栗子</a></li>
<li><a href="#1.2.2">1.2.2 函数式接口</a></li>
<li><a href="#1.2.3">1.2.3 方法与构造函数的引用</a></li>
</ul>
</li>
<li><a href="#1.3">1.3 java.util.function</a></li>
<li><a href="#1.4">1.4 Stream API</a></li>
<li><a href="#1.5">1.5 Optional</a></li>
</ul>
<h2><span id='1.'>1.-1.8新特性</span></h2>
<h3><span id='1.1'>1.1 接口可有非抽象方法</span></h3>
<ul>
<li>允许给接口提供非抽象方法，就像抽象类一样可以有非抽象方法<font color='red'>(可以有多个)</font></li>
<li>但要在非抽象方法前使用<code>default</code>关键字</li>
<li>这一特性叫做<strong>扩展方法或<font color='red'>默认方法</font></strong> </li>
</ul>
<hr />
<pre><code>interface Formula {
 double calculate(int a);     //接口本身的抽象方法

 【default】 double sqrt(int a) {  //【扩展方法】非抽象的，前面有default关键字
    return Math.sqrt(a);
  }
}
</code></pre>

<hr />
<pre><code>Formula formula = new Formula() {  //创建上述接口的匿名内部类
    @Override
    public double calculate(int a) {  //重写了接口的抽象方法
        return sqrt(a * 100);  //接口的【扩展方法】可直接调用
    }
};

formula.calculate(100); // 100.0
formula.sqrt(16); // 4.0
</code></pre>

<blockquote>
<p>两种冲突的形式</p>
</blockquote>
<ul>
<li>（1）接口有默认方法，类中有一个和接口一样的方法。有一个子类继承了该类，实现了该接口，调用该方法，可能会引起冲突，此时遵循“类优先原则”，即调用的是类的方法，接口的方法会被忽略</li>
<li>（2）两个接口都有相同的默认方法，一个子类多实现这两个接口，调用该方法时，要求在子类中重写该方法，这样避免了冲突</li>
</ul>
<blockquote>
<p>接口中也可以定义静态的方法，写法和用法都是老规矩。</p>
</blockquote>
<h3><span id='1.2'>1.2 lambda表达式</span></h3>
<blockquote>
<p>完整的语法形式</p>
</blockquote>
<pre><code>(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; {  //参数类型Type可以省略
  statment1;
  statment2;
  //.............
  return statmentM;
 }
</code></pre>

<blockquote>
<p>简化形式：</p>
</blockquote>
<pre><code>1.单参数形式
  --可以省略小括号
 name -&gt; {xxxx}

=====================================

2.单语句形式
   -- 当函数体里面只有一条语句时，可以省略以下：
     * 大括号
     * return关键字
     * 语句结尾的分号【;】

eg1  :   
name - &gt; System.out.println(name)  //省略大括号，分号【;】，无返回值不涉及return

eg2  :
原始写法：
Collections.sort(names, (String a, String b) -&gt; {
  return b.compareTo(a);
});

lambda写法：
Collections.sort(names, (a, b) -&gt; b.compareTo(a));   //省略参数类型，大括号，省略return关键字，省略语句结尾分号【;】

=====================================

3.参数的数据类型可以省略
* jvm的编译器可以通过上下文推断出数据类型：“类型推断”
    * String arr[] = {&quot;aa&quot;,&quot;bb&quot;};
    * List&lt;String&gt; list = new ArrayList&lt;&gt;();  //【jdk1.7】
    * public void show(Map&lt;String,String&gt; map) 调用：show(new HashMap&lt;&gt;()) //【jdk1.8】
</code></pre>

<blockquote>
<p><font color='red'>变量的作用域</font></p>
<p>lambda表达式{}中变量的作用域和【局部内部类】一样</p>
</blockquote>
<pre><code>* 可以引用外部类的成员变量，静态变量【视所处于方法是否为静态而定】
* 可以引用方法中定义的变量【final修饰，jdk1.8进行优化不用显式final】 
* 可以自定义变量
    * 其实lambda表达式就相当于重写匹配类/接口中的方法
    * 方法中定义的变量的那一套规矩（不能在方法中定义静态变量。。。。。）
</code></pre>

<blockquote>
<p><font color='red'>lambda中的this</font></p>
</blockquote>
<pre><code>* lambda表达式相当于对应一个【局部内部类】   
* lambda表达式中的this对应的是【外部类】
    * 传统的局部内部类中this对应自身
    * 如：Outter$1Inner
        * 匿名内部类：Outter$1
        * 成员内部类: Outer$Inner
</code></pre>

<h4><span id='1.2.1'>1.2.1 举个栗子</span></h4>
<p><strong>(1) Collections.sort()</strong></p>
<pre><code>List names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

// list集合排序
Collections.sort(names, new Comparator() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});

lambda写法：
Collections.sort(names, (a, b) -&gt; b.compareTo(a));      
</code></pre>

<p><strong>(2) new Thread(new Runnable(){xx});</strong></p>
<pre><code>new Thread(new Runnable() {
     @Override
     public void run() {
       System.out.println(&quot;Before Java8, too much code for too little to do&quot;);
      }
    }).start();

lambda写法：
new Thread( () -&gt; System.out.println(&quot;In Java8, Lambda expression rocks !!&quot;) ).start();
</code></pre>

<h4><span id='1.2.2'>1.2.2 函数式接口</span></h4>
<ul>
<li>
<p>每一个lambda表达式都表示一个类型 <strong>通常是接口类型</strong></p>
</li>
<li>
<p>“函数式接口”指仅包含一个抽象方法的接口</p>
</li>
<li>
该类型的lambda表达式都会被匹配到这个抽象方法。
<ul>
<li>
<font color='red'>lambda表达式表示一个接口类型</font>
<ul>
<li>Runnable runnable = ()-&gt; System.out.println(&quot;this is run method&quot;);</li>
</ul>
</li>
<li>
<font color='red'>该接口类型的lambda表达式匹配到该接口中的唯一的一个抽象方法上</font>
<ul>
<li>此处指Runnable接口的唯一一个抽象方法：run()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<pre><code>*  注意：该函数式接口中仅一个抽象方法！
*  lambda表达式映射到此单方法的接口上
*  因此，可以将lambda表达式当作任意只包含一个抽象方法的接口类型，需满足条件
    *  在该单方法的接口上添加： @FunctionalInterface 注解
        *  Runnable接口和Comparator就有这个注解
    *  标注了这个注解的接口有多于一个抽象方法的时候会报错的。
</code></pre>

<hr />
<pre><code>@FunctionalInterface
interface Converter {
 &lt;T&gt; T convert(T from);
}

【Converter converter = (from) -&gt; Integer.valueOf(from);】  //attention~

Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted); // 123
</code></pre>

<h4><span id='1.2.3'>1.2.3 方法与构造函数引用</span></h4>
<p><font color='red'>也是作为函数式接口中抽象函数的函数体的一部分，可以看做是lambda表达式的另一种表现形式</font></p>
<p><strong>&emsp;&emsp;以1.2.2的Converter接口为例</strong></p>
<blockquote>
<p>方法引用</p>
</blockquote>
<ul>
<li>（1）类名.静态方法</li>
<li>
<font color='red'>把lambda表达式匹配到的【抽象函数参数】作为【lambda表达式所表示的方法的参数】</font>
<ul>
<li>Integer::valueOf 匹配 T convert(F from)这一抽象函数的参数是from</li>
<li>Integer::valueOf这一lambda表达式所表示的方法是Integer.valueOf(xxx)</li>
<li>因此from这一参数作为Integer.valueOf(xxx)ff的参数--&gt; Integer.valueOf(from);</li>
</ul>
</li>
</ul>
<hr />
<pre><code>Converter converter = Integer::valueOf;
//1. 如4.2.2所说，lambda表达式表示一个接口类型，由等号左边的引用类型可以确定该lambda表达式表示的是Converter接口类型
//2. 如4.2.2所说，lambda表达式匹配到该接口类型中唯一一个抽象方法（此处是 T convert(F from)）这一抽象方法
//3. 因此，Converter converter = Integer::valueOf;等同于：将Converter接口中的抽象方法【T convert(F from)】的方法体设置为：Integer.valueOf(from)
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted); // 123
</code></pre>

<hr />
<ul>
<li>（2）对象.实例方法</li>
<li>
<font color='red'>与（1）种情况相同</font>
<ul>
<li>
Converter converter = System.out::println;
<ul>
<li>等同： <font color='red'>System.out.println(from)</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>（3）类名.实例方法</li>
</ul>
<p>语法：如<code>String::toUpperCase</code>  //一定是【方法名::实例方法】</p>
<p><font color='red'>前面两种情况可以说是一个类型，<strong>本类型要注意</strong></font>
  等同于把lambda表达式所匹配的抽象方法的第一个参数当成instanceMethod的目标对象，其他剩余参数当成该方法的参数。</p>
<pre><code>比如：

interface MyInter {
  String fun1(String str1,String str2);
}

MyInter myInter = String::connect;
//String::connect这一lambda表达式匹配MyInter#fun1方法；
//str1作为connect（）方法的目标对象，后续参数作为connect（）方法的参数
//即：str1.connect(str2);
String result = myInter.fun1(&quot;aa&quot;,&quot;bb&quot;); // result为&quot;aabb&quot;
</code></pre>

<p><strong>总结</strong></p>
<p>（1）（2）方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p>
<p>（3）若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName）</p>
<blockquote>
<p>构造器引用</p>
</blockquote>
<p>&emsp; 语法: <code>ClassName::new</code></p>
<p><font color='red'>&emsp;把lambda表达式匹配的抽象方法的参数作为ClassName构造函数的参数<br/>
&emsp;【Person::new】  &emsp; 等同  &emsp; 将该表达式匹配到的抽象函数方法的参数attr--&gt; new Person(attr);</font></p>
<pre><code>//Person类，姓名+构造函数
class Person{
    String name;

    public Person(String name) {
     this.name = name;
    }
}

//工厂
interface PersonFactory{
  Person create(String name);
}

//执行
public class Main {
    public static void main(String[] args) {
        PersonFactory personFactory = Person::new;
        // 匹配到PersonFactory#create的参数name
        Person person = personFactory.create(&quot;hg&quot;);
        // 相当于 new Perspn(&quot;hg&quot;);
        System.out.println(person. name);  //hg
    }   
}  
</code></pre>

<blockquote>
<p>数组引用</p>
</blockquote>
<p>&emsp; 语法: <code>类型[] :: new;</code></p>
<pre><code>//数组引用
@Test
public void test8(){
    Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args];
    String[] strs = fun.apply(10);
    System.out.println(strs.length);

    System.out.println(&quot;--------------------------&quot;);

    Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new;
    Employee[] emps = fun2.apply(20);
    System.out.println(emps.length);
}
</code></pre>

<h3><span id='1.3'> 1.3 java.util.function</span></h3>
<ul>
<li>Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程</li>
</ul>
<hr />
<ul>
<li>
<p>Java8 内置的四大核心函数式接口</p>
<ul>
<li>
<p>Consumer&lt;T&gt; : 消费型接口
void accept(T t);</p>
</li>
<li>
<p>Supplier&lt;T&gt; : 供给型接口
T get(); </p>
</li>
<li>
<p>Function&lt;T, R&gt; : 函数型接口
R apply(T t);</p>
</li>
<li>
<p>Predicate&lt;T&gt; : 断言型接口
boolean test(T t);
<img src="https://i.imgur.com/5s79oQj.png" /></p>
</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>消费型</p>
</blockquote>
<pre><code>//Consumer&lt;T&gt; 消费型接口 :
@Test
public void test1(){
    happy(10000, (m) -&gt; System.out.println(&quot;你们刚哥喜欢大宝剑，每次消费：&quot; + m + &quot;元&quot;));
} 

public void happy(double money, Consumer&lt;Double&gt; con){
    con.accept(money);
}
</code></pre>

<blockquote>
<p>供给型接口</p>
</blockquote>
<pre><code>//Supplier&lt;T&gt; 供给型接口 :
@Test
public void test2(){
    List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100));

    for (Integer num : numList) {
        System.out.println(num);
    }
}

//需求：产生指定个数的整数，并放入集合中
public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup){
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    for (int i = 0; i &lt; num; i++) {
        Integer n = sup.get();
        list.add(n);
    }

    return list;
}
</code></pre>

<blockquote>
<p>函数型接口：</p>
</blockquote>
<pre><code>@Test
public void test3(){
    String newStr = strHandler(&quot;\t\t\t 我大尚硅谷威武   &quot;, (str) -&gt; str.trim());
    System.out.println(newStr);

    String subStr = strHandler(&quot;我大尚硅谷威武&quot;, (str) -&gt; str.substring(2, 5));
    System.out.println(subStr);
}

//需求：用于处理字符串
public String strHandler(String str, Function&lt;String, String&gt; fun){
    return fun.apply(str);
}
</code></pre>

<blockquote>
<p>断言型接口：</p>
</blockquote>
<pre><code>//Predicate&lt;T&gt; 断言型接口：
@Test
public void test4(){
    List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;atguigu&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;);
    List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3);

    for (String str : strList) {
        System.out.println(str);
    }
}

//需求：将满足条件的字符串，放入集合中
public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre){
    List&lt;String&gt; strList = new ArrayList&lt;&gt;();

    for (String str : list) {
        if(pre.test(str)){
            strList.add(str);
        }
    }

    return strList;
}
</code></pre>

<h2><span id='1.4'>1.4 Stream API</span></h2>
<p>Stream 是 Java8 中<strong>处理集合（数组）的关键抽象概念</strong>，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，
Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<ul>
<li>数据源（集合、数组），以流水线式的中间操作（不对数据源产生影响），产生新流</li>
<li>
对应三个步骤：
<ol>
<li>创建流Stream</li>
<li>一系列中间操作（操作链，不涉及执行）</li>
<li>终止操作</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ul>
<li>其不同于io流</li>
<li>Stream 自己不会存储元素。</li>
<li>&quot;惰性求值&quot;/&quot;延迟加载&quot;：终止操作执行时才会执行“中间操作”指定的操作</li>
</ul>
<h3><span id='1.4.1'>1.获取Stream</span></h3>
<p><strong>获取Stream有四种方式：</strong></p>
<ul>
<li>
<p>Java8 中的 Collection 接口被扩展：</p>
<p>获取串行流：<code>collection # stream()</code></p>
<p>获取并行流：<code>collection # parallelStream()</code></p>
</li>
</ul>
<hr />
<ul>
<li>
<p>Java8 中的 Arrays 被扩展：</p>
<p>通过静态方法获取数组流：<code>Arrays.stream(数组)</code></p>
</li>
</ul>
<hr />
<ul>
<li>
<p>Stream类中的静态方法：</p>
<p><code>Stream.of(T .. val)</code></p>
</li>
</ul>
<hr />
<ul>
<li>
<p>Stream类中的静态方法<strong>创建无限流</strong>：</p>
<p>(1)【无限】 迭代：<code>Stream.iterate(final T seed, final
UnaryOperator&lt;T&gt; f)</code></p>
<p>Stream<Integer> stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(10);
stream3.forEach(System.out::println);</p>
</li>
</ul>
<p><font color='red'>
&emsp;&emsp;seed:作为第一个起始的元素</p>
<p>&emsp;&emsp;UnaryOperator：一元运算，将seed作为第一个起始元素，开始往后进行不断迭代的一元运算
</font></p>
<p>&emsp;&emsp; (2) 【无限】生成：<code>Stream.generate(Supplier&lt;T&gt; s)</code></p>
<h3><span id='1.4.2'>2.中间操作</span></h3>
<p><strong><font color='red'>中间操作核心就是一个【产生新流】的过程</font></strong></p>
<p><strong>筛选与切片</strong></p>
<p><img src="https://i.imgur.com/sbscakY.png" /></p>
<ul>
<li>其中，limit具有“短路”特性，即找到满足条件的前n个就不再判读执行（而不是进行全部的遍历判断后再选取前n个）</li>
<li>distinct去重是通过对象的hashCode方法和equals方法去重的</li>
</ul>
<p><strong>映射</strong></p>
<p><img src="https://i.imgur.com/zi01q9Y.png" /></p>
<p><strong>排序</strong></p>
<p><img src="https://i.imgur.com/x1FI82P.png" /></p>
<ul>
<li>自然排序：就是按照对象的实现了Comparable中的compareTo方法比较</li>
<li>定制排序：就是传入一个比较器Comparator,重写compare方法进行定制排序</li>
</ul>
<h3><span id='1.4.3'>3.终止操作</span></h3>
<p><strong><font color='red'>核心就是对中间操作进行之后产生的新流，进行最后的收尾终止操作</font></strong></p>
<p><strong>查找与匹配</strong></p>
<p><img src="https://i.imgur.com/4mdlCdv.png" /></p>
<ul>
<li><strong>findFirst()和findAny()返回的是Optional,通过optional.get()获取其中的值</strong></li>
</ul>
<p><img src="https://i.imgur.com/yEoTfBc.png" /></p>
<p><strong>归约</strong></p>
<p><img src="https://i.imgur.com/wSPZhrJ.png" /></p>
<ul>
<li>第一种形式，第一个参数iden其实作为起始元素，第二个参数是一个二元运算，传入两个数返回一个数【由于有起始参数，不可能返回值null,所以不用返回Optional来防止空指针】</li>
<li>第二种形式，直接对stream中的元素进行二元运算，可能为null，返回optional</li>
</ul>
<hr />
<pre><code>第一种：
List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);   
Integer sum = list.stream()
                  .reduce(0, (x, y) -&gt; x + y);  //相加操作

第二种：（员工的工资相加）
Optional&lt;Double&gt; op = emps.stream()
        .map(Employee::getSalary)
        .reduce(Double::sum); //对应1.8在Double引入的double sum(double a, double b)方法
</code></pre>

<p><strong>收集</strong>		</p>
<p><img src="https://i.imgur.com/jLzEDTG.png" /></p>
<ul>
<li>Collector 接口中方法的实现决定了如何对流执行收集操作(如收
集到 List、 Set、 Map)。</li>
<li>但是 <strong>Collectors</strong> 实用类提供了很多静态
方法，可以方便地创建常见收集器实例</li>
<li>具体方法与实例如下表：</li>
</ul>
<hr />
<p><em>收集到集合</em></p>
<ul>
<li><code>list.stream().collect(Collectors.toList());</code></li>
<li><code>list.stream().collect(Collectors.toSet());</code> </li>
<li><code>list.stream().collect(Collectors.toCollection(HashSet::new)););</code> </li>
</ul>
<p><em>max,min，平均等信息</em></p>
<ul>
<li><code>long count = list.stream().collect(Collectors.counting());</code> 个数</li>
<li><code>inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary));</code>总和</li>
<li><code>doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));</code>平均值</li>
<li><code>IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</code></li>
<li><code>Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</code>最大值</li>
<li><code>Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));</code>最小值</li>
</ul>
<p><em>合并</em></p>
<ul>
<li><code>String str= list.stream().map(Employee::getName).collect(Collectors.joining());</code></li>
<li><code>collect(Collectors.joining(&quot;,&quot; , &quot;----&quot;, &quot;----&quot;));</code> //逗号分割，首尾</li>
</ul>
<p><em>归约</em></p>
<ul>
<li><code>.collect(Collectors.reducing(Double::sum));</code> </li>
</ul>
<p><em>分组+分区</em></p>
<p><img src="https://i.imgur.com/lF9WeYD.png" /></p>
<p><strong>并行流+串行流</strong></p>
<ul>
<li>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</li>
<li>底层还是分支合并框架</li>
</ul>
<hr />
<pre><code> Long sum = LongStream.rangeClosed(0L, 10000000000L)
                      .parallel()
                      .sum();
</code></pre>

<h2><span id='1.5'>1.5 Optional</span></h2>
<p><img src="https://i.imgur.com/HbT5AJ2.png" /></p>
<ul>
<li>
静态方法获取Optional实例
<ul>
<li>Optional.of(new Person()); 如果of的参数为null--》抛空指针</li>
<li>Optional.empty(); 创建的一个Optional实例，但这个实例对象【容器】里面无值</li>
<li>
<strong>Optional.ofNullable(new Person());如果T不为空则创建实例</strong>
<ul>
<li>Optional.ofNullable(null)；如果T为null则创建空的Optional实例</li>
<li><strong>其实是of和empty的综合</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>判断Optional容器是否包含值：isPresent();</li>
</ul>
<hr />
<ul>
<li>
容器包含值就返回，不包含就指定一个默认的返回：orElse()
<ul>
<li>相当于sql中的IFNULL(&quot;age&quot;,0)函数</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
容器包含值就返回，不包含就返回一个由Suppiler指定的值：orElseGet(Suppiler s)
<ul>
<li>相比于orElse()，orElseGet（）传递一个Suppiler可以添加相关的逻辑判断</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
map(Function f) --&gt; 返回值为Optional
<ul>
<li>如果容器中没有值，直接返回Optional.empty();</li>
<li>如果容器中有值，对其值进行操作后产生一个映射处理后的结果</li>
<li>在源代码中会将映射处理结果使用Optioanl.ofNullable(结果)封装为Optional返回</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
flatMap(Function mapper) --&gt; 返回值为Optional
<ul>
<li>与上一个map()相比，map传递的function的返回值为任意的，内部会将function的返回结果封装为Optional</li>
<li>flatMap要求传递的function对象的返回值就为Optional</li>
<li>其他都相同，要求根据传递的function映射处理返回一个Optional</li>
</ul>
</li>
</ul>
<hr />
<p>运用Optional：【找出man心中的女神】</p>
<pre><code>//运用 Optional 的实体类
@Test
public void test6(){
    Optional&lt;Godness&gt; godness = Optional.ofNullable(new Godness(&quot;林志玲&quot;));

    //godness作为一个Optional类型的成员
    Optional&lt;NewMan&gt; op = Optional.ofNullable(new NewMan(godness));
    String name = getGodnessName2(op);
    System.out.println(name);
}

public String getGodnessName2(Optional&lt;NewMan&gt; man){
 //传递的man可能为null,godness可能为null,通过orElse解决
    return man.orElse(new NewMan())
              .getGodness()
              .orElse(new Godness(&quot;苍老师&quot;))
              .getName();
}
</code></pre>

<h2><span id='1.6'>1.6 日期API</span></h2>
<ul>
<li>
供人看的日期
<ul>
<li>LocalDate</li>
<li>LocalTime</li>
<li>LocalDateTime</li>
</ul>
</li>
</ul>
<p><strong>都是不可变的对象，使用的【iso-8601】的日历系统</strong></p>
<p><img src="https://i.imgur.com/nktkAqe.png" /></p>
<hr />
<ul>
<li>
<p>供电脑看的时间戳【毫秒数】</p>
<ul>
<li><strong>unix元年，1970年1月1日0:0:0起始的毫秒数</strong></li>
<li>
<p>Instant</p>
<ul>
<li>默认获取的是UTC市区的时间，而不是系统的时间</li>
<li>
<p>中国北京时间【东8区】，要在utc的时间上加8小时</p>
<p>Instant instant = Instant.now();</p>
<p>//北京时间（在utc基础上加8小时）</p>
<p>OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));</p>
</li>
<li>
<p>获取毫秒值</p>
<p>now.toEpochMilli();</p>
</li>
<li>
<p>构造Instant</p>
<p>Instant instant = Instant.ofEpochSecond(1000);【unix时间上加上1000秒】</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>两个时间之间的间隔</p>
<ul>
<li>
<p>Duration</p>
<p>Duration between = Duration.between(inst1, inst2);</p>
<p>between.toMillis()   【获取时间相差的毫秒值】</p>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>两个日期之间的间隔</p>
<ul>
<li>
<p>Period</p>
<p>//start,end是LocalDate对象</p>
<p>Period between = Period.between(start, end);</p>
<p>//调用Period对象between的相关方法</p>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>时间校正器：</p>
<ul>
<li>TemporalAdjuster：有时我们可能需要获取例如：将日期调整到“下个周日”等操作</li>
<li>
<p>工具类提供静态方法：<strong>TemporalAdjusters</strong></p>
<p>//获取下周星期日</p>
<p>LocalDateTime now = LocalDateTime.now();</p>
<p>//【with（）方法】</p>
<p>LocalDateTime nextSunday = now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));</p>
<p>System.out.println(nextSunday); </p>
</li>
<li>
<p><strong>自定义时间校正器：</strong></p>
<ul>
<li>由于with方法传递的参数是TemporalAdjuste接口，重写改接口中的方法Temporal adjustInto(Temporal temporal);</li>
<li>方法中的参数类型Temporal是LocalDateTime的父类，将temporal向下转型为LocalDateTime类型后进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>格式化：DateTimeFormatter</p>
<pre><code>//指定格式
DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm:ss&quot;);
LocalDateTime now = LocalDateTime.now();
String format = formatter.format(now);

//解析字符串【静态方法】
LocalDateTime.parse(format,formatter)
</code></pre>

</li>
</ul>
<hr />
<ul>
<li>
<p>时区处理</p>
<ul>
<li>ZonedDate、 ZonedTime、 ZonedDateTime</li>
<li>
其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式
<ul>
<li>如 ： Asia/Shanghai </li>
</ul>
</li>
<li>getAvailableZoneIds() : 可以获取所有时区时区信息</li>
<li>
<p>of(id) : 用指定的时区信息获取 ZoneId 对象</p>
<pre><code>//获取所有的时区ID
Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();
availableZoneIds.forEach(System.out::println);

-----------------------------------------------------------------

//获取指定时区的当地时间
LocalDateTime now = LocalDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));

//变为带时区的格式，同时指定了相对UTC的偏移量
ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(&quot;Asia/Shanghai&quot;));

//zonedDateTime===》对应为2018-05-17T17:36:59.939+08:00[Asia/Shanghai]
</code></pre>

</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/kdwV2hy.png" /></p>
<hr />
<ul>
<li>
注解改进
<ul>
<li>Java 8对注解处理提供了两点改进：【可重复的注解】及【可用于类型的注解】
<img src="https://i.imgur.com/3C1jVl1.png" /></li>
</ul>
</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
