<!DOCTYPE html>
<html>
<head>
<title>mysql2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<p>官网:dev.mysql.com</p>
<p>window下配置文件：my.ini</p>
<p>linux下可存放配置文件的几个地方（加载顺序如下）：/etc/mysql/my.cnf  &emsp;/etc/my.cnf &emsp; ~/.my.cnf </p>
<p>mysqld --verbose --help | grep -A 1 'Default options' : 查看“help”中“Default options”位置及after后面的1行</p>
<hr />
<h3>mysql在linux安装后无密码:</h3>
<ul>
<li>设置：/usr/bin/mysqladmin -u root password 123456</li>
<li>查看：mysqldumpadmin --version</li>
<li>启停：service mysql start/stop</li>
<li>设置开机自启：chkconfig mysql on</li>
<li>查看开机自启项：chkconfig --list</li>
<li>ntsysv：出现窗口看到启动项（table键退出）</li>
</ul>
<hr />
<h3>查看数据库文件</h3>
<ul>
<li>
ps -ef | grep -i mysql (-i 忽略大小写)
<ul>
<li>/var/lib/mysql  : 存放数据库数据</li>
<li>/usr/share/mysql : 存放配置文件</li>
<li>/usr/bin         : 指令</li>
<li>/etc/init.d/mysql : 启停相关脚本</li>
</ul>
</li>
</ul>
<hr />
<h3>设置编码</h3>
<p>拷贝mysql配置文件：cp /var/share/mysql/my-huge.cnf  /etc/my.cnf</p>
<ul>
<li>
[client]
<ul>
<li>default-character-set=utf8</li>
</ul>
</li>
<li>
[mysqld]
<ul>
<li>character-set-server=utf8</li>
<li>character-set-client=utf8</li>
<li>collation-server=utf8_general_ci</li>
</ul>
</li>
<li>
[mysql] 
<ul>
<li>default-character-set=utf8</li>
</ul>
</li>
</ul>
<hr />
<h3>分层架构</h3>
<p>(1). 连接层</p>
<p>&emsp;&emsp;最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>(2). 服务层</p>
<p>&emsp;&emsp;第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。|</p>
<p>(3) 引擎层</p>
<p>&emsp;&emsp;存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MylSAM和InnoDB</p>
<p>(4) 存储层</p>
<p>&emsp;&emsp;数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
<p><img src="https://i.imgur.com/ibGgUC2.png" /></p>
<hr />
<h3>存储引擎</h3>
<p><code>show engines;</code></p>
<p><code>show variables like '%storage_engine%'</code></p>
<p><img src="https://i.imgur.com/lRUl9Fp.png" /></p>
<ul>
<li>两种存储引擎的文件格式</li>
<li>事务，外键</li>
<li>表锁，行锁</li>
<li>count(*)</li>
<li>myisam支持全文索引</li>
<li>myisam缓存索引，innodb缓存索引+数据</li>
</ul>
<p><img src="https://i.imgur.com/XEMwNZK.png" /></p>
<p><strong><font color='blue'>myISAM引擎的文件</font></strong></p>
<ul>
<li>frm文件：数据库表结构</li>
<li>myd文件：数据</li>
<li>myi文件：索引</li>
</ul>
<p><strong><font color='blue'>Innodb引擎的文件</font></strong></p>
<ul>
<li>frm文件</li>
<li>opt文件</li>
</ul>
<hr />
<h3>索引</h3>
<ul>
<li>排好序的快速查找的数据结构</li>
<li>数据库除了维护数据，还要维护一个特定查找的数据结构（即索引）</li>
<li>一般来说索引也很大，不可能全部存在内存中，也会以文件的形式存储在磁盘中。</li>
<li>【查询】+【排序】：索引会影响where后的查找和order by后的排序</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>类似图书馆建立索引，提高数据检索效率，减少数据库io</li>
<li>对数据进行排序，降低数据排序成本，降低cpu消耗</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>索引也是一张表，保存索引字段，占据空间</li>
<li>提高查询速度的同时，降低了更新速度（因为除了维护数据还要维护索引）</li>
</ul>
<blockquote>
<p>索引的数据结构</p>
</blockquote>
<ul>
<li>Btree</li>
<li>hash(<font color='red'>只有memory引擎支持hash索引</font>)</li>
<li>fulltext</li>
<li>r-tree</li>
</ul>
<p><img src="https://i.imgur.com/YR5wzEH.png" /></p>
<blockquote>
<p>索引的分类</p>
</blockquote>
<ol>
<li>单值索引：一个索引只包含一个列，一个表可以有多个单列索引</li>
<li>复合索引：一个索引包含多个列</li>
<li>唯一索引：索引值必须唯一，但允许有空值</li>
<li>全文索引：<font color='red'>仅可用于 MyISAM表</font>，一般在char,varchar,text上建立</li>
</ol>
<blockquote>
<p>操作索引的语法</p>
</blockquote>
<p><strong>直接创建</strong>
&emsp;create [unique] index  idx_user_name on user(name,xxx);</p>
<p><strong>修改创建</strong></p>
<p><img src="https://i.imgur.com/npTDkTK.png" /></p>
<p><strong>删除</strong>：
drop index index<em>name on table</em>name;</p>
<p><strong>查看</strong>：
show index from table_name;</p>
<blockquote>
<p>创建索引的情况</p>
</blockquote>
<ul>
<li>主键自动建立唯一索引</li>
<li>表之间外键关系建立索引</li>
<li></li>
<li>频繁作为查询条件(select)的字段应该创建索引</li>
<li>Where条件中用不到的字段不创建索引</li>
<li>查询统计：order by / group by</li>
<li>distinct , 经常用于做表连接的字段上</li>
<li>对于数据很少被更新的表，使用覆盖索引，覆盖经常要查询的字段</li>
</ul>
<blockquote>
<p>不创建索引的情况</p>
</blockquote>
<ul>
<li>表记录太少</li>
<li>经常增删改的表:频繁更新的字段不应该作为索引【因为数据变动，索引跟着也变动】</li>
<li>某列重复内容过多 如sex字段</li>
</ul>
<hr />
<h3>explain:查看执行计划</h3>
<p>使用explain关键字可以模拟优化器<font color='red'>执行sql查询语句</font>，从而知道mysql如何执行sql语句，从而分析查询语句和表结构找出性能瓶颈</p>
<ul>
<li><font color='blue'>explain + select 语句</font></li>
</ul>
<p><img src="https://i.imgur.com/CTeJXnT.png" /></p>
<ul>
<li>
id 
<ul>
<li>数字越大执行的优先级越高</li>
</ul>
</li>
<li>
select_type（查询种类：对应select操作）
<ul>
<li>simple:查询不包含子查询和union</li>
<li>primary: 子查询最外层 【or】 合并结果集的前者( 即最后加载的就是primary)</li>
<li>subquery: 子查询</li>
<li>derived:在from列表中包含的子查询被标记为derived，mysql会递归执行这些子查询，把结果放在【临时表】里。</li>
<li>union：合并结果集的后者</li>
<li>union result：合并后的最终结果</li>
</ul>
</li>
<li>table</li>
<li>
<font color='red'><strong>type</strong></font>
<ul>
<li><font color='red' size=3>最好到最坏排列： system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all </font></li>
<li>system:表只包含一条记录，const的理想型</li>
<li>const: 表示通过一次索引就找到了，用于比较primary key[主键索引]或[unique索引]，如where  id = 1【涉及索引的使用】</li>
<li>eq_ref：唯一性索引扫描，一个索引键匹配到的记录只有一条（CEO只有一个）,用于比较primary key[主键索引]或[unique索引] 【涉及索引的使用】</li>
<li>ref: 通过索引查询，一个索引键匹配到的记录有多个（java工程师岗位的职员有多个）   【涉及索引的使用】</li>
<li>range: &gt;=  / between / in / or ......    【涉及索引的使用】   
</li>
<li>index：全索引扫描（扫描整个索引树）:通常比ALL快，因为索引文件通常比数据文件小。【涉及索引的使用】     
</li>
<li>all：全表扫描</li>
</ul>
</li>
<li>
possiable_keys
<ul>
<li>mysql内部分析出本次sql可能会涉及到的索引，【但实际执行中可能并不会都使用到】</li>
</ul>
</li>
<li>
key：实际sql执行中使用到的索引
<ul>
<li>null ：可能没有建索引 or 可能建了索引没有使用   == 》【统称为‘索引失效’】</li>
</ul>
</li>
<li>
key_len：
<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li>
</ul>
</li>
<li>ref：显示索引哪一列被引用了</li>
<li>rows:</li>
<li>
extra:
<ul>
<li>using filesort : 如果通过索引排序不显示，排序未用到索引就显示filesort(文件内部自己重新排序)</li>
<li>using temporary : (产生了新建的临时表 order by / group by)</li>
<li>
useing index : 使用了【<font color='red'>覆盖索引</font>】:查询的select数据列和索引列重合，直接从索引中就能获得，无需通过索引再次读取数据文件  

<ul>
<li>如果同时出现using where : 表明索引用于了查询</li>
<li>如果未同时出现using where ：表明索引用来读取数据，而非查找数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h3>索引优化</h3>
<ul>
<li>
<p>单表</p>
<p>三个字段上建立索引:A,B,C;查询时使用where A='' and B &gt; '' order by C；第二个索引B使用范围导致后续索引失效，order by排序出现using filesort</p>
<p>解决：不为第二个字段建索引，保证了索引的建立顺序和使用顺序匹配（<strong>最佳左前缀原则</strong>）</p>
</li>
<li>
<p>两表（多表）</p>
<p>左（右）连接进行关联查询的时候，索引建在右（左）表上，即反过来。因为外连接的时候本表所有记录一定有，关键是看对方的表如何搜索，所以建在对方表上。</p>
</li>
</ul>
<h4>避免索引失效</h4>
<ul>
<li>全值匹配最好</li>
<li>
最佳左前缀（带头大哥不能少，中间兄弟不能断）
<ul>
<li>建立A,B,C三个索引；实际使用：where A='' AND C=''</li>
<li>中间跳过了B，导致只使用A一个索引，C失效 </li>
</ul>
</li>
<li>
不要在索引列字段上做任何操作，否则会导致全表扫描
<ul>
<li>如操作了索引列A：where left(A,4) = ''</li>
</ul>
</li>
<li>
索引范围后的索引失效
<ul>
<li>where A='' AND B&gt;'' AND C=''</li>
<li>使用到了A,B;B后面的索引C失效</li>
</ul>
</li>
<li>
尽量使用【覆盖索引】,减少select *
<ul>
<li>使用覆盖索引，其对应查询字段直接从索引中获取，而不需再次读取数据文件</li>
<li>extra列显示：using index </li>
</ul>
</li>
<li>
使用!=或者&lt;&gt;导致失效，从而导致全表扫描
<ul>
<li>where A!=''</li>
</ul>
</li>
<li>
IS NULL / IS NOT NULL也会导致索引失效无法使用上
<ul>
<li>IS NULL : type列为null</li>
<li>IS NOT NULL : type列为all(全表扫描) </li>
</ul>
</li>
<li>
like 'xx%'：使用like模糊查询时，%加在右边
<ul>
<li>如果一上来%加在左边最前面将导致不确定性，转而进行全表扫描 </li>
<li><font color='red'>解决：使用覆盖索引，保证select查询的字段列和索引字段列重合</font>
<img src="https://i.imgur.com/jyHiTxf.png" /></li>
</ul>
</li>
<li>
字符串不加单引号，导致索引失效 
<ul>
<li>where A=100;其实是进行了自动类型转换为===》where A='100'</li>
</ul>
</li>
<li>
or连接索引失效：
<ul>
<li>where A='xx' or A='xxx';</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<p><img src="https://i.imgur.com/5bedaSw.png" /></p>
<p><img src="https://i.imgur.com/KlfC4vZ.png" /></p>
<p><strong><font color='red'>补充说明【最佳前缀匹配】</font></strong></p>
<ul>
<li>where和order by后的字段列共同可构成连续字段列，与索引列进行匹配</li>
<li>索引列是ABCD,实际使用的为：where B='' AND A='' AND D='' AND C=''这样子的乱序也是可以的，mysql底层的优化器会自动调序</li>
<li>例：where A='' AND B='' AND D&gt;'' AND C=''；等价于 where A='' AND B='' AND C='' AND D &gt;'' ；用到了4个索引</li>
<li>
例: 【where A='' AND B='' AND D='' order by C;】【where A='' AND B='' order by c;】
<ul>
<li>上述两者等效，统计中只使用到了A,B两个索引</li>
<li>其实C也用到了，只是用于了排序</li>
<li>C用于排序后导致了索引列的连续性断掉，D失效</li>
</ul>
</li>
<li>
where A='' AND B='' order by D；
<ul>
<li>特别指出一下：出现了using filesort; </li>
</ul>
</li>
<li>
例： where A='' Oder by B,C；
<ul>
<li>统计只使用到了A索引</li>
<li>B,C索引其实也用到了，用于了排序</li>
<li>无using filesort</li>
</ul>
</li>
<li>
例： where A='' order by C,B；
<ul>
<li>注意是order by C,B；出现using filesort</li>
</ul>
</li>
<li>
<font color='red'>例： where A='' order by B,A;</font>
<ul>
<li>注意A此时已经是一个常量了，等同于where A='' order by B;</li>
<li>不会出现using filesort;</li>
</ul>
</li>
</ul>
<p><font color='blue'><strong>group by表示分组，其实在分组之前还是会涉及排序，并产生临时表</strong></font></p>
<p><strong><font color='red'>注意区分【索引覆盖】和【最佳前缀匹配】</font></strong></p>
<ul>
<li>
<strong>索引覆盖</strong>:针对的是select后面要查询的字段
<ul>
<li>只要需要查询的字段是索引列的子集（无关顺序，无关是否连续）</li>
<li>只要是索引列“罩得住”查询字段列，就称之为“索引覆盖”</li>
<li>extra:using index;</li>
</ul>
</li>
<li>
<strong>最佳前缀匹配</strong>:针对的是where后面的条件字段和order by(或者group by)后面的字段共同构成的字段序列
<ul>
<li>指的是“其共同构成的字段序列”与索引列满足“从左到右的连续匹配”</li>
<li>则这时order by不至于产生using filesort</li>
<li>则这时group by不至于产生using temporary</li>
</ul>
</li>
</ul>
<hr />
<h3>查询优化</h3>
<p><img src="https://i.imgur.com/hPf27xS.png" /></p>
<ul>
<li>永远用小表驱动大表（保证外层for循环是小的）</li>
<li>
<p><img src="https://i.imgur.com/cUCOpHw.png" /></p>
</li>
<li>
<p>exists相当于是in的替代</p>
</li>
<li><img src="https://i.imgur.com/2w3Y6IG.png" /></li>
</ul>
<hr />
<blockquote>
<p>order by</p>
</blockquote>
<ul>
<li>两种情况：using filesort【避免】 | using index【ok】</li>
<li>
创建一个复合索引index(A,B)
<ul>
<li>where A&gt;'' order B,A；【using filesort】</li>
<li>order by A asc, B desc;【using filesort】<strong>同升同降才是ok的</strong></li>
</ul>
</li>
<li>
<font color='red'>两种情况使用到的是using index:</font>
<ul>
<li><strong>order by后面的字段满足最佳左前缀</strong></li>
<li><strong>where后的字段和order by后的字段共同满足最佳左前缀</strong> </li>
</ul>
</li>
<li>
如果产生using filesort,将产生单路和双路复用：
<ul>
<li>双路：读两次</li>
<li>单路：存到内存中（注意内存不够可能导致“偷鸡不成到蚀一把米”；调节sort_buffer缓冲区）</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/g89JCwy.png" /></p>
<blockquote>
<p>group by</p>
</blockquote>
<ul>
<li>与order by 相同</li>
<li>1.创建临时表 2.拷贝数据  3.删除临时表</li>
<li>产生临时表。分组之前涉及order by</li>
<li><font color='red'>能用where限定的不用having限定</font></li>
</ul>
<blockquote>
<p>优化策略</p>
</blockquote>
<ul>
<li>增大<code>sort_buffer_size</code>参数</li>
<li>增大<code>max_length_for_sort_data</code>参数</li>
</ul>
<hr />
<h3>慢日志查询</h3>
<ul>
<li>超过5分钟的查询sql进行记录，结合explain分析</li>
<li>
默认是关闭的：<code>show variables like '%slow_query_log%'</code>  -- &gt; off
<ul>
<li>开启：<code>set global slow_query_log = 1</code>  -- &gt; 只对当前本数据库有效，重启失效</li>
<li>
永久生效，需要在配置文件中进行修改：在[mysqld]下添加：
<ul>
<li><code>slow_query_log = 1</code></li>
<li><code>slow_query_log_file = xxxx</code> </li>
<li><code>long_query_time = 3</code></li>
<li><code>log_output = FILE</code></li>
</ul>
</li>
</ul>
</li>
<li>
默认的<code>long_query_time</code>:10s  

<ul>
<li><code>show variables like '%long_query_time%'</code></li>
</ul>
</li>
<li>
设置：<code>set global long_query_time = 3;</code>
<ul>
<li>设置后查看无效，需要重新的一个新会话 或者  <code>show global variables like '%long_query_time%'</code></li>
<li>同样可以命令修改 或 配置文件修改</li>
<li>注意：是大于10s才会记录，而非大于等于</li>
</ul>
</li>
</ul>
<p><strong>demo</strong></p>
<pre><code>select sleep(4);  //睡4秒
show global status like 'Slow_queries%';  //查看被记录的慢查询数
</code></pre>

<blockquote>
<p>mysqldumpslow</p>
</blockquote>
<ul>
<li>MYSQL自带的日志帮助分析工具： <code>mysqldumpslow -- help</code>【<strong>该命令无需登录mysql</strong>】</li>
</ul>
<p><img src="https://i.imgur.com/ZJd1iVA.png" /></p>
<p><img src="https://i.imgur.com/wtU62fF.png" /></p>
<blockquote>
<p>批量插入数据</p>
</blockquote>
<ul>
<li>编写sql脚本（函数中循环体）</li>
<li>
在编写脚本的函数之前
<ul>
<li>查看这一变量：<code>show variables like 'log_bin_trust_function_createors';</code></li>
<li>设置：<code>set global log_bin_trust_function_createors = 1;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>show profile</p>
</blockquote>
<ul>
<li>比explain更加细粒度,是mysql用来分析当前会话中语句执行的资源消耗情况。</li>
<li>
<p>默认是关闭的，保存当前15次的执行情况。</p>
<ul>
<li>查看：<code>show variables like 'profiling'</code> -- &gt; off</li>
<li>设置：<code>set profiling = on</code></li>
</ul>
</li>
<li>
<p>命令</p>
<ul>
<li><code>show profiles;</code> 查看记录的sql情况</li>
<li><code>show profile cpu,block io for query xxx(query_id);</code></li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/AXZRTqh.png" /></p>
<p><img src="https://i.imgur.com/EQGV7WW.png" /></p>
<blockquote>
<p>全局日志查询</p>
</blockquote>
<ul>
<li>只用于测试环境上启用这个功能，不要在生产环境中使用</li>
<li>
开启
<ul>
<li>
方法1[修改配置文件]
<ul>
<li><code>general_log = 1</code> &amp;&amp;  <code>general_log_file = xxx</code>  &amp;&amp; <code>log_output = FILE</code></li>
</ul>
</li>
<li>
方法2[设置]
<ul>
<li><code>set global general_log=1;</code>  
</li>
<li><code>set global log_output='TABLE'</code></li>
</ul>
</li>
</ul>
</li>
<li>
开启以后，编写的sql语句会记录到  【mysql库中的general_log表中】 -- &gt;  出厂默认自带的表
<ul>
<li>查看：<code>select * from mysql.general_log;</code></li>
</ul>
</li>
</ul>
<hr />
<h3>锁</h3>
<ul>
<li>按读写分：读锁（共享），写锁（独占，排它）</li>
<li>按粒度分：表锁，行锁</li>
</ul>
<p><strong>2x2=4种：表的读、写锁，行的读、写锁</strong></p>
<blockquote>
<p>表锁（偏读）</p>
</blockquote>
<ul>
<li>偏向myisam引擎，开销小，加锁快</li>
<li>无死锁，锁定粒度大</li>
<li>发生冲突概率不高，并发度最低</li>
</ul>
<p>1.创建表，指定MyIASM引擎</p>
<pre><code>create table xx()engine myisam;
</code></pre>

<p>2.上锁</p>
<pre><code>lock table table_name read(write),table_name2 read(write);
</code></pre>

<p>3.释放全部表上的锁</p>
<pre><code>unlock tables;
</code></pre>

<p>4.其他</p>
<pre><code> 查看表的加锁情况：show open tables;
 分析系统上的表锁定：show status like 'table%' 
</code></pre>

<p><img src="https://i.imgur.com/eOmtavs.png" /></p>
<p><img src="https://i.imgur.com/Dz4nNrQ.png" /></p>
<blockquote>
<p>行锁（偏写）</p>
</blockquote>
<ul>
<li>
针对innoDB，开销大，加锁慢
<ul>
<li><strong>innoDB引擎支持事务，支持行级锁</strong></li>
</ul>
</li>
<li>会出现死锁，锁定粒度最小</li>
<li>发生锁冲突概率最低，并发度最高</li>
</ul>
<p><strong><font color='red'>为了演示下面的操作，将默认事务提交关闭：<code>set autocommit=off</code></font></strong></p>
<p><strong>索引使用不当（如varchar使用自动类型转换）会导致行锁变为表锁，操作同一张表的不同行也导致了阻塞</strong></p>
<p><strong>（1）间隙锁的危害</strong></p>
<p><code>update user set name = 'new' where id between 1 and 7;</code> &emsp;session1执行完之后未commit</p>
<p><code>insert into user values(5,'05');</code>&emsp;session2针对‘间隙’进行插入，会阻塞，直到session1提交</p>
<p><img src="https://i.imgur.com/Xw2v262.png" /></p>
<p><strong>（2）如何锁定一行</strong></p>
<p><img src="https://i.imgur.com/1uchyai.png" /></p>
<p><strong>（3）行锁分析</strong></p>
<p>命令：<code>show status like 'innodb_row_lock'</code></p>
<p><img src="https://i.imgur.com/swBZi0r.png" /></p>
<blockquote>
<p>页锁</p>
</blockquote>
<ul>
<li>开销和加锁时间介于表锁和行锁之间，会出现死锁</li>
<li>锁定粒度介于表锁和行锁之间，并发度一般</li>
</ul>
<hr />
<h1>主从复制</h1>
<h2><a href="https://www.cnblogs.com/gl-developer/p/6170423.html">博客</a></h2>
<p><img src="https://i.imgur.com/tb5Z3Ss.png" /></p>
<p>主从复制：一对多的关系</p>
<ul>
<li>mysql版本一致，并且以后台服务运行（可通信，能ping通）</li>
<li>配置在[mysqld]节点下</li>
</ul>
<h4>(1）配置文件的配置</h4>
<p><strong>windows作为主机：</strong></p>
<pre><code>  server-id = 1  【必须配置，主服务器唯一id】
  log-bin = 路径/mysqlbin  【必须配置(启用二进制日志)，建议遵守官方的要求：路径+“/mysqlbin”】

  -----------------------------------------------------------------------

  log-err = 路径/mysqlerr   【可选项】
  basedir = 路径            【可选项,类似于java_home根目录】
  tmpdir= 路径        【可选项】
  datadir = 路径/data       【可选项，数据库中的数据存放位置】
  readonly=0  主机读写都可以
  binlog-ignore-db=mysql   忽略默认的mysql库
  binlog-do-db=xxx       要复制的数据库[不显示配置代表复制所有的数据库]
</code></pre>

<p><strong>linux作从机</strong></p>
<pre><code>【必须】从机唯一id【server-id = 2】
【可选】开启二进制日志
</code></pre>

<p><font color='red'>主从mysql服务器重启+主从的防火墙关闭</font></p>
<h4>(2）主从关系的命令配置</h4>
<p><strong>windows</strong></p>
<pre><code>1. 配置其slave登录方式
    GRANT REPLICATION SLAVE ON *.* TO 'zhangsan'@'从机ip' IDENTIFIED BY '123456'
2. 刷新
    FLUSH PRIVILEGES;
3. 查看
    SHOW MASTER STATUS;
</code></pre>

<p><strong>linux</strong></p>
<pre><code>(1)
  CHANGE MASTER TO MASTER_HOST='主机ip',
  MASTER_USER='zhangsan',
  MASTER_PASSWORD='123456',
  MASTER_LOG_FILE='mysqlbin.000001',  #从window主机获取
  MASTER_LOG_POS=107; #从window主机获取

2. 启动
  start slave;
3. 查看
  show slave status\G
 （slave_io_running+slave_sql_running都为yes,表示ok）
4. 关闭
  stop slave;
</code></pre>

<h4>(2）主机创建表会同步到slave</h4>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
